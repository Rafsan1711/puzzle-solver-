<!DOCTYPE html>
<html lang="bn" class="scroll-smooth">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Puzzle ‚Äî Solver (Final)</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat libs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    body { background:#0d1117; color:#c9d1d9; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #homeScreen,#gameContainer { background:#161b22cc; box-shadow:0 8px 24px rgba(12,17,23,0.6); }
    #toggleSlider { background:#238636; }
    .tile {
      position:absolute;
      width: calc(100% / var(--grid-size) - 0.75rem);
      height: calc(100% / var(--grid-size) - 0.75rem);
      display:flex; align-items:center; justify-content:center;
      border-radius:0.5rem; cursor:pointer; user-select:none;
      font-size:2.5rem; font-weight:800; color:#e1e4e8;
      background:linear-gradient(145deg,#3a3f4b,#2c303a);
      box-shadow:0 6px 12px rgba(0,0,0,0.8), inset 0 3px 6px rgba(255,255,255,0.05);
      transition: transform 0.28s ease;
      text-shadow:0 0 4px #0008; backface-visibility:hidden;
    }
    .tile.hard { font-size:1.5rem; }
    .tile:hover { background:linear-gradient(145deg,#2c5f37,#1f3f22); color:#7fffd4; box-shadow:0 10px 20px rgba(35,134,54,0.7), inset 0 3px 7px rgba(255,255,255,0.15); transform:scale(1.06) var(--translate); z-index:10; text-shadow:0 0 8px #7fffd4cc; }
    .tile.empty { background:transparent; box-shadow:none; cursor:default; pointer-events:none; }
    #grid { position:relative; width:100%; height:100%; --grid-size:3; }

    /* wrap main app so we can blur/dim it without affecting overlays */
    #appWrap { width:100%; max-width:900px; display:flex; flex-direction:column; align-items:center; }
    #appWrap.dim { filter: blur(6px) brightness(0.45); pointer-events:none; transition: filter .18s ease; }

    #modalOverlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); align-items:center; justify-content:center; z-index:100; }
    #modal { background:#21262d; padding:2rem; border-radius:1rem; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.7); }
    #modal h2 { font-size:2rem; margin-bottom:1rem; color:#58a6ff; }
    #modal button { margin-top:1rem; padding:0.75rem 1.5rem; background:#238636; color:white; border:none; border-radius:0.5rem; font-size:1rem; cursor:pointer; transition:background 0.2s; }
    #modal button:hover { background:#2ea043; }

    #controls { width:100%; max-width:40rem; margin-top:24px; display:none; justify-content:center; gap:12px; align-items:center; }

    .controls-column { width:100%; display:flex; flex-direction:column; gap:10px; align-items:center; }
    .btn-wide { width:100%; max-width:360px; padding:0.72rem 1.2rem; border-radius:0.75rem; font-size:1.05rem; font-weight:700; cursor:pointer; color:white; border:none; box-shadow:0 8px 20px rgba(0,0,0,0.6); }
    #solveBtn { background:#16a34a; }
    #setCustomBtn { background:#0ea5a4; }
    #solveBtn:hover{ background:#169e43; transform:translateY(-2px); }
    #setCustomBtn:hover{ background:#119191; transform:translateY(-2px); }
    #solveBtn:disabled{ background:#285c38; cursor:not-allowed; opacity:.85; transform:translateY(0); }

    #customWrapper { width:100%; max-width:360px; display:none; margin-top:6px; background:#0f1720; padding:12px; border-radius:10px; box-shadow:0 4px 20px rgba(0,0,0,0.5); }
    .field-row { display:flex; gap:8px; align-items:center; margin-bottom:8px; width:100%; }
    label { color:#9fb3c8; width:72px; font-weight:700; }
    select, input[type="number"] { flex:1; padding:0.5rem 0.6rem; border-radius:8px; background:#071018; color:#dbeafe; border:1px solid #21343b; }
    .small-btn { padding:0.45rem 0.7rem; border-radius:8px; border:none; cursor:pointer; font-weight:700; }

    #thinking-container { max-width: 360px; margin: 20px auto 40px auto; padding: 18px 22px; background-color: #202124; border-radius: 14px; box-shadow:0 0 0 1px rgba(255,255,255,0.1), 0 1px 3px rgba(0,0,0,0.4); color: #e8eaed; }
    #thinking-text { font-size: 1.3rem; font-weight: 600; background: linear-gradient(90deg,#e8eaed 20%,#121212 40%,#e8eaed 60%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shine-slide 2.5s linear infinite; }
    @keyframes shine-slide { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    #thinking-subtext { margin-top: 12px; font-style: italic; font-weight: 400; color: #c7c7c7; min-height: 26px; font-size: 1rem; white-space: nowrap; }

    #progressBarWrap { width:100%; max-width:34rem; margin:20px auto 0 auto; background:#23272e; border-radius:0.7rem; height:1.2rem; box-shadow:0 2px 8px #0005; overflow:hidden; position:relative; }
    #progressBar { height:100%; background:linear-gradient(90deg,#238636,#58a6ff); width:0%; transition:width 0.5s; }
    #progressText { position:absolute; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; font-size:.98rem; color:#fff; font-weight:700; text-shadow:0 2px 8px #0009; pointer-events:none; }

    /* compute-card overlay sits above appWrap so card not blurred */
    #computeCardOverlay { display:none; position:fixed; inset:0; align-items:center; justify-content:center; z-index:120; }
    #computeBackdrop { position:absolute; inset:0; background:rgba(0,0,0,0.55); backdrop-filter: blur(2px); }
    #computeCard { position:relative; z-index:130; width:min(720px,94%); background:rgba(16,20,24,0.98); border-radius:12px; padding:18px; color:#e6eef6; box-shadow:0 10px 40px rgba(0,0,0,0.7); }
    #computeCard h3 { font-size:1.25rem; margin-bottom:6px; color:#58a6ff; }
    #computeCard .moves { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .pill { background:#17202a; padding:6px 8px; border-radius:8px; font-weight:700; }
    #computeCard .bottom { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    #saveStatus { margin-right:auto; align-self:center; color:#9fb3c8; }
    #estimateText { color:#9fb3c8; margin-top:6px; }

    .dim-background { filter: blur(4px) brightness(0.6); pointer-events: none; }

    @media (max-width:640px){ #controls{ padding:0 12px; margin-top:26px; } .btn-wide{ max-width:92%; } }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-6">

  <!-- wrap main UI so overlays aren't blurred -->
  <div id="appWrap">
    <!-- Home -->
    <div id="homeScreen" class="w-full max-w-md p-8 rounded-3xl text-center mb-10 select-none">
      <h1 class="text-white text-5xl font-extrabold mb-8 drop-shadow-lg">Sliding Puzzle Game</h1>
      <div class="relative inline-block w-full bg-gray-800 rounded-full overflow-hidden shadow-inner">
        <div id="toggleSlider" class="absolute top-0 left-0 rounded-full h-full w-1/3 transition-all duration-300 ease-in-out"></div>
        <div class="flex text-gray-300 font-semibold text-xl cursor-pointer">
          <div data-mode="easy" class="flex-1 py-4 z-10">Easy</div>
          <div data-mode="normal" class="flex-1 py-4 z-10">Normal</div>
          <div data-mode="hard" class="flex-1 py-4 z-10">Hard</div>
        </div>
      </div>
      <button id="startBtn" class="mt-10 w-full bg-green-600 hover:bg-green-700 text-white py-4 rounded-2xl text-2xl font-semibold shadow-lg transition duration-300">
        Start Game
      </button>
      <p class="text-sm text-gray-400 mt-3">‡¶ó‡ßá‡¶Æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶≤‡ßá ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ <strong>Solve</strong> ‡¶¨‡¶æ‡¶ü‡¶® ‡¶¶‡¶ø‡ßü‡ßá ‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ì (‡¶¨‡¶æ ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶°‡ßá <strong>B</strong> ‡¶ö‡¶æ‡¶™‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã)‡•§</p>
    </div>

    <!-- Game container -->
    <div id="gameContainer" class="hidden w-full max-w-lg aspect-square rounded-3xl p-6 flex flex-col relative">
      <div id="grid"></div>
    </div>

    <!-- Progress bar -->
    <div id="progressBarWrap" style="display:none;">
      <div id="progressBar"></div>
      <div id="progressText"></div>
    </div>

    <!-- Controls below board -->
    <div id="controls">
      <div class="controls-column">
        <div id="thinkingSmall" aria-hidden="true"></div>
        <div id="winner-message"></div>
        <div id="game-board"></div>
        <div id="thinking-container" role="status" aria-live="polite" aria-atomic="true" aria-label="Bot thinking status">
          <div id="thinking-text">Solving With Stages...</div>
          <div id="thinking-subtext"></div>
        </div>

        <button id="solveBtn" class="btn-wide" title="Bot Solve">Solve</button>
        <button id="setCustomBtn" class="btn-wide">Set Custom Position</button>

        <div id="customWrapper">
          <div class="field-row"><label>Tile</label>
            <select id="tileSelect"></select>
          </div>
          <div class="field-row"><label>Row</label>
            <select id="rowSelect"></select>
          </div>
          <div class="field-row"><label>Column</label>
            <select id="colSelect"></select>
          </div>
          <div style="display:flex; gap:8px; margin-top:6px;">
            <button id="applyBtn" class="small-btn" style="flex:1;background:#7c3aed;color:white;">Apply</button>
            <button id="computeBtn" class="small-btn" style="flex:1;background:#0ea5a4;color:white;">Compute</button>
          </div>
          <button id="computeInfoBtn" style="background:transparent;border:none;color:#9fb3c8;margin-top:8px;text-decoration:underline;">Compute ‡¶ì Efficiency ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
        </div>

      </div>
    </div>
  </div> <!-- end appWrap -->

  <!-- Modal -->
  <div id="modalOverlay" class="flex">
    <div id="modal">
      <h2>üéâ You Solved It!</h2>
      <p class="text-gray-300">Congratulations on completing the puzzle.</p>
      <button id="closeModal">Close</button>
    </div>
  </div>

  <!-- Compute info slide-up modal -->
  <div id="computeInfoOverlay">
    <div id="computeInfoPanel">
      <div id="computeInfoInner">
        <h3 style="color:#58a6ff; font-size:1.2rem; margin-bottom:6px;">Compute & Efficiency</h3>
        <p style="color:#b9d0e6; line-height:1.45;">Compute ‡¶ü‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶¶‡¶ø‡¶≤‡ßá worker limited BFS/IDA ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá targeted ‡¶ü‡¶æ‡¶á‡¶≤‡¶ï‡ßá goal-‡¶è ‡¶¨‡¶∏‡¶æ‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßá ‚Äî ‡¶∏‡¶Æ‡ßç‡¶™‡ßÇ‡¶∞‡ßç‡¶£ 5√ó5 IDA ‡¶®‡¶æ ‡¶ö‡¶æ‡¶≤‡¶ø‡ßü‡ßá ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶ü‡¶æ‡¶á‡¶≤ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ‡¶≠‡¶æ‡¶¨‡ßá compute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø‡•§</p>
        <ul style="color:#9fb3c8; margin-top:8px;">
          <li>‚Ä¢ compute-‡¶è node/time limits ‡¶Ü‡¶õ‡ßá ‚Äî ‡¶¨‡ßú search-‡¶è ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡¶æ‡¶∞ freeze ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ‡¶á ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø‡•§</li>
          <li>‚Ä¢ Firebase-‡¶è cached result ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶Ü‡¶ó‡ßá ‡¶§‡¶æ ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá ‚Äî ‡¶®‡¶§‡ßÅ‡¶® compute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§</li>
          <li>‚Ä¢ tile=1 ‡¶Ø‡¶ñ‡¶® bottom-right (row=size, col=size) ‡¶è ‡¶Ü‡¶õ‡ßá, compute ‡¶ï‡¶∞‡ßá movedTiles (‡¶ï‡ßã‡¶® ‡¶ï‡ßã‡¶® ‡¶ü‡¶æ‡¶á‡¶≤ ‡¶∏‡¶∞‡¶æ‡¶®‡ßã ‡¶≤‡¶æ‡¶ó‡¶≤) ‡¶°‡¶æ‡¶ü‡¶æ ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ‡¶≠‡¶æ‡¶¨‡ßá save ‡¶π‡¶¨‡ßá ‚Äî ‡¶™‡¶∞‡ßá reuse ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá‡•§</li>
        </ul>
        <div style="display:flex; justify-content:space-between; margin-top:12px;">
          <button id="closeInfoBtn" style="background:#16a34a; color:white; padding:8px 12px; border-radius:8px; border:none;">Close</button>
          <button id="learnMoreBtn" style="background:transparent; color:#9fb3c8; border:none; text-decoration:underline;">More details (dev)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Compute result card overlay (with backdrop) -->
  <div id="computeCardOverlay">
    <div id="computeBackdrop"></div>
    <div id="computeCard">
      <div style="display:flex; gap:12px; align-items:start;">
        <div style="flex:1;">
          <h3 id="cardTitle">Compute Result</h3>
          <div id="cardMeta" style="color:#9fb3c8; font-size:0.95rem;">Tile: <strong id="metaTile">-</strong> ‚Ä¢ Pos: <strong id="metaPos">-</strong></div>
          <div id="estimateText">Estimating...</div>
          <div style="margin-top:8px;">Moves:</div>
          <div id="movesList" class="moves"></div>
          <div style="margin-top:8px;" id="movedTilesWrap"></div>
          <div class="bottom">
            <div id="saveStatus">Not saved yet</div>
            <button id="cardClose" style="background:#444; color:white; padding:8px 12px; border-radius:8px; border:none;">Close</button>
            <button id="cardSave" style="background:#0ea5a4; color:white; padding:8px 12px; border-radius:8px; border:none;">Save to Firebase</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* -------------------- firebase configs (your three configs) -------------------- */
const config1 = {
  apiKey: "AIzaSyCMEqtaxOodPnwMKkrSVZrcjLMmj3oefB0",
  authDomain: "chatstudio-agent.firebaseapp.com",
  databaseURL: "https://chatstudio-agent-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "chatstudio-agent",
  storageBucket: "chatstudio-agent.firebasestorage.app",
  messagingSenderId: "626338448826",
  appId: "1:626338448826:web:67936971701c3466d90983",
  measurementId: "G-ZHNZHMYC0B"
};
const config2 = {
  apiKey: "AIzaSyAKd2WmThKb4OM9pv0Bx9vtunmGpRGxczM",
  authDomain: "puzzle-solver-5-2.firebaseapp.com",
  databaseURL: "https://puzzle-solver-5-2-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "puzzle-solver-5-2",
  storageBucket: "puzzle-solver-5-2.firebasestorage.app",
  messagingSenderId: "221283910343",
  appId: "1:221283910343:web:0bef0b54fe26e594c8f4e2"
};
const config3 = {
  apiKey: "AIzaSyDohgyc4pRldMVxbFRTkHnNfAIczf8JHMo",
  authDomain: "puzzle-solver-4-1.firebaseapp.com",
  databaseURL: "https://puzzle-solver-4-1-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "puzzle-solver-4-1",
  storageBucket: "puzzle-solver-4-1.firebasestorage.app",
  messagingSenderId: "422133823015",
  appId: "1:422133823015:web:0daf2ce34fa8fe98eac002"
};
/* ------------------------------------------------------------------------------ */

/* -------------------- core UI & solver variables -------------------- */
const appWrap = document.getElementById('appWrap');
const homeScreen = document.getElementById('homeScreen');
const gameContainer = document.getElementById('gameContainer');
const gridEl = document.getElementById('grid');
const toggleSlider = document.getElementById('toggleSlider');
const startBtn = document.getElementById('startBtn');
const modalOverlay = document.getElementById('modalOverlay');
const closeModal = document.getElementById('closeModal');
const controls = document.getElementById('controls');
const solveBtn = document.getElementById('solveBtn');

const setCustomBtn = document.getElementById('setCustomBtn');
const customWrapper = document.getElementById('customWrapper');
const tileSelect = document.getElementById('tileSelect');
const rowSelect = document.getElementById('rowSelect');
const colSelect = document.getElementById('colSelect');
const applyBtn = document.getElementById('applyBtn');
const computeBtn = document.getElementById('computeBtn');
const computeInfoBtn = document.getElementById('computeInfoBtn');
const computeInfoOverlay = document.getElementById('computeInfoOverlay');
const closeInfoBtn = document.getElementById('closeInfoBtn');

const computeCardOverlay = document.getElementById('computeCardOverlay');
const metaTile = document.getElementById('metaTile');
const metaPos = document.getElementById('metaPos');
const movesList = document.getElementById('movesList');
const cardClose = document.getElementById('cardClose');
const cardSave = document.getElementById('cardSave');
const saveStatus = document.getElementById('saveStatus');
const estimateText = document.getElementById('estimateText');
const movedTilesWrap = document.getElementById('movedTilesWrap');

const progressBarWrap = document.getElementById('progressBarWrap');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

const modes = { easy:{size:3, path:'easy'}, normal:{size:4, path:'normal'}, hard:{size:5, path:'hard'} };
let currentMode = 'easy';
let size, tiles = [], emptyIndex;

/* -------------------- mode & grid UI -------------------- */
document.querySelectorAll('[data-mode]').forEach(el=>{
  el.addEventListener('click', ()=> {
    currentMode = el.dataset.mode;
    const idx = ['easy','normal','hard'].indexOf(currentMode);
    toggleSlider.style.left = `${idx*33.3333}%`;
    const p = modes[currentMode].path;
    if(location.pathname!=="/"+p) history.replaceState({}, '', "/"+p);
  });
});
(function setModeFromUrl(){
  const path = location.pathname.replace(/^\//,'');
  if(path && Object.values(modes).some(m=>m.path===path)){
    currentMode = Object.keys(modes).find(k=>modes[k].path===path) || "easy";
  }
  const idx = ['easy','normal','hard'].indexOf(currentMode);
  toggleSlider.style.left = `${idx*33.3333}%`;
})();

function getTranslate(index){
  const row = Math.floor(index/size), col = index%size;
  const tileSize = gridEl.clientWidth/size;
  return { x: col*tileSize, y: row*tileSize };
}

function createGrid(gridSize){
  size = gridSize;
  gridEl.style.setProperty('--grid-size', size);
  gridEl.innerHTML = '';
  tiles = Array.from({length:size*size-1},(_,i)=>i+1);
  tiles.push(null);
  shuffleTiles(tiles,size);
  emptyIndex = tiles.indexOf(null);

  tiles.forEach((num,i)=>{
    if(num===null) return;
    const tile = document.createElement('div');
    tile.className = 'tile';
    if(currentMode==='hard') tile.classList.add('hard');
    tile.textContent = num;
    const {x,y} = getTranslate(i);
    tile.style.transform = `translate(${x}px,${y}px)`;
    tile.dataset.number = num;
    tile.dataset.position = i;
    gridEl.appendChild(tile);
  });
  controls.style.display = 'flex';
  progressBarWrap.style.display = 'block';
  populateCustomSelectors();
  updateProgressBar();
}

function shuffleTiles(arr,s){
  do{
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }while(!isSolvable(arr,s)||isSolved(arr));
}

function isSolvable(arr,s){
  let inv=0, flat=arr.filter(x=>x!==null);
  for(let i=0;i<flat.length;i++)
    for(let j=i+1;j<flat.length;j++)
      if(flat[i]>flat[j]) inv++;
  if(s%2) return inv%2===0;
  const er = Math.floor(arr.indexOf(null)/s);
  return er%2?inv%2===0:inv%2!==0;
}

function isSolved(arr){
  for(let i=0;i<arr.length-1;i++) if(arr[i]!==i+1) return false;
  return arr[arr.length-1]===null;
}

function tryMove(tile){
  const tilePos = +tile.dataset.position;
  const emptyPos = emptyIndex;
  const r1 = Math.floor(tilePos/size), c1 = tilePos%size;
  const r2 = Math.floor(emptyPos/size), c2 = emptyPos%size;
  const adj = (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
  if(!adj) return false;
  [tiles[tilePos],tiles[emptyPos]]=[tiles[emptyPos],tiles[tilePos]];
  const {x,y} = getTranslate(emptyPos);
  tile.style.transform = `translate(${x}px,${y}px)`;
  tile.dataset.position = emptyPos;
  emptyIndex = tilePos;
  updateProgressBar();
  return true;
}

gridEl.addEventListener('click', e=>{
  const tile = e.target.closest('.tile');
  if(!tile) return;
  if(tryMove(tile) && isSolved(tiles)){
    modalOverlay.style.display = 'flex';
    updateProgressBar();
  }
});

startBtn.addEventListener('click', ()=>{
  homeScreen.classList.add('hidden');
  gameContainer.classList.remove('hidden');
  createGrid(modes[currentMode].size);
});

closeModal.addEventListener('click', ()=>{ modalOverlay.style.display = 'none'; });

window.addEventListener('resize', ()=>{
  tiles.forEach(num=>{
    if(num===null) return;
    const tile = [...gridEl.children].find(t=>+t.dataset.number===num);
    if(!tile) return;
    const {x,y} = getTranslate(+tile.dataset.position);
    tile.style.transform = `translate(${x}px,${y}px)`;
  });
});

// progress
function calcProgress(arr, sz){
  if(sz===3) {
    let cnt=0;
    for(let i=0;i<8;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/8*100);
  }
  if(sz===4) {
    let cnt=0;
    for(let i=0;i<15;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/15*100);
  }
  if(sz===5){
    let stage1=0, total=0;
    const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
    for(const i of st1idx) if(arr[i]===i+1) stage1++;
    for(let i=0;i<24;i++) if(arr[i]===i+1) total++;
    return Math.round((stage1/12*70)+(total/24*30));
  }
  return 0;
}
function updateProgressBar(){
  if(!tiles||!size) return;
  const perc = calcProgress(tiles,size);
  progressBar.style.width = perc+"%";
  progressText.textContent = perc+"% solved";
  if(perc===100) progressText.textContent = "üéâ Puzzle Solved!";
}

/* -------------------- worker solver (kept intact) -------------------- */
function solverWorkerFunction(){
  self.onmessage = function(ev){
    try{
      const {type, state, size, targetTile} = ev.data;
      if(type !== 'solve' && type !== 'compute_tile') return;
      const startState = state.slice();

      function idxToRC(i){ return {r: Math.floor(i/size), c: i%size}; }
      const goalPos = {}; for(let v=1; v<=size*size-1; v++) goalPos[v] = idxToRC(v-1);

      function manhattanUnfixed(arr, fixedSet){
        let s = 0;
        for(let i=0;i<arr.length;i++){
          const v = arr[i]; if(v==null) continue;
          const gi = v-1; if(fixedSet && fixedSet.has(gi)) continue;
          const cur = idxToRC(i), g = goalPos[v];
          if(!g) continue;
          s += Math.abs(cur.r - g.r) + Math.abs(cur.c - g.c);
        }
        return s;
      }

      function neighborsOfEmpty(emptyIdx){
        const res=[];
        const r=Math.floor(emptyIdx/size), c=emptyIdx%size;
        const deltas=[{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
        for(const d of deltas){
          const nr=r+d.dr, nc=c+d.dc;
          if(nr>=0 && nr<size && nc>=0 && nc<size) res.push(nr*size+nc);
        }
        return res;
      }

      function bfsPlaceTile(currentState, fixedSet, targetVal, targetGoalIdx){
        const start = currentState.slice();
        const startEmpty = start.indexOf(null);
        const key = s => s.map(x=>x===null?'_':x).join(',');
        const Queue = [];
        const Seen = new Set();
        Queue.push({arr:start.slice(), empty:startEmpty, path:[]});
        Seen.add(key(start));
        const maxNodes = 400000;
        let nodes=0;
        const maxDepth = 80;
        while(Queue.length){
          const node = Queue.shift();
          nodes++;
          if(nodes > maxNodes) break;
          if(node.arr[targetGoalIdx] === targetVal) return node.path.slice();
          if(node.path.length >= maxDepth) continue;
          const neigh = neighborsOfEmpty(node.empty);
          for(const idx of neigh){
            if(fixedSet && fixedSet.has(idx)) continue;
            const newA = node.arr.slice();
            const moved = newA[idx];
            newA[node.empty] = moved;
            newA[idx] = null;
            const k = key(newA);
            if(Seen.has(k)) continue;
            Seen.add(k);
            const newPath = node.path.slice(); newPath.push(moved);
            Queue.push({arr:newA, empty: idx, path:newPath});
          }
        }
        return null;
      }

      function idaPlaceTarget(currentState, fixedSet, targetVal, targetGoalIdx, nodeCap=600_000, tCap=10_000){
        const state = currentState.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, fixedSet); }
        let threshold = h();
        const path = [];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, fixedSet);
          const f = g + hv;
          if(f > threshold) return f;
          if(state[targetGoalIdx] === targetVal) { found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            if(fixedSet.has(idx)) return {idx, hv2: 1e9};
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, fixedSet);
            state[idx]=val; state[eidx]=null;
            return {idx, hv2};
          }).filter(Boolean).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti = o.idx;
            if(prev !== undefined && ti === prev) continue;
            if(fixedSet.has(ti)) continue;
            const v = state[ti];
            state[eidx] = v; state[ti] = null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r === 'FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti] = v; state[eidx] = null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r === 'FOUND') return found;
          if(r === Infinity || nodes > nodeCap) break;
          threshold = r;
          if(Date.now() - t0 > tCap) break;
        }
        return null;
      }

      function idaFull(initial, nodeCap=5_000_000, tCap=30_000){
        const state = initial.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, new Set()); }
        let threshold = h();
        const path=[];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, new Set());
          const f = g + hv;
          if(f > threshold) return f;
          if(hv===0){ found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, new Set());
            state[idx]=val; state[eidx]=null;
            return {idx,hv2};
          }).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti=o.idx;
            if(prev !== undefined && ti===prev) continue;
            const v = state[ti];
            state[eidx]=v; state[ti]=null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r==='FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti]=v; state[eidx]=null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r==='FOUND') return found;
          if(r===Infinity || nodes>nodeCap) break;
          threshold = r;
          if(Date.now()-t0 > tCap) break;
        }
        return null;
      }

      if(type === 'compute_tile'){
        const working = startState.slice();
        const targetVal = targetTile;
        const goalIdx = targetVal - 1;
        const fixed = new Set();
        const moves = bfsPlaceTile(working, fixed, targetVal, goalIdx);
        self.postMessage({type:'compute_result', target:targetVal, moves:moves});
        return;
      }

      // full solver for 'solve' kept as before...
      if(size === 4){
        const working = startState.slice();
        let allMoves = [];
        const fixedIndices = new Set();
        try{
          for(let c=0; c<size; c++){
            const targetVal = c+1;
            const goalIdx = c;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 300000, 4000);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          for(let i=4;i<=5;i++){
            const targetVal = i+1;
            const goalIdx = i;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 200000, 3500);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          const restMoves = idaFull(working, 600000, 16000);
          if(restMoves&&restMoves.length>0){
            for(const mv of restMoves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            self.postMessage({type:'done', moves:allMoves, method:'4x4_stage2_ida'});
            return;
          }else{
            self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'4x4_stage2_fail'});
            return;
          }
        }catch(e){
          self.postMessage({type:'done', moves:null, method:'4x4_exception', error:String(e)});
          return;
        }
      }

      if(size===5){
        const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
        const working = startState.slice();
        let allMoves = [];
        const fixedIndices = new Set();
        try{
          for(const i of st1idx){
            const targetVal = i+1;
            const goalIdx = i;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue;}
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 170000, 3000);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'5x5_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'5x5_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          const restMoves = idaFull(working, 400000, 9000);
          if(restMoves&&restMoves.length>0){
            for(const mv of restMoves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            self.postMessage({type:'done', moves:allMoves, method:'5x5_stage2_ida'});
            return;
          }else{
            self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'5x5_stage2_fail'});
            return;
          }
        }catch(e){
          self.postMessage({type:'done', moves:null, method:'5x5_exception', error:String(e)});
          return;
        }
      }

      if(size<=3){
        const moves = idaFull(startState);
        self.postMessage({type:'done', moves:moves, method:'3x3_ida'});
        return;
      }

      const fallback = idaFull(startState, 150000, 7000);
      self.postMessage({type:'done', moves:fallback, method:'fallback_ida'});
    }catch(e){
      self.postMessage({type:'done', moves:null, method:'worker_crash', error: String(e)});
    }
  };
}

/* create worker blob/url */
const workerBlob = new Blob(['('+solverWorkerFunction.toString()+')()'], {type:'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);

/* solver run (unchanged) */
let solverWorker = null;
let solverRunning = false;
let queuedMoves = [];

function startSolver(){
  if(solverRunning) return;
  if(gameContainer.classList.contains('hidden')) return;
  solverRunning = true;
  solveBtn.disabled = true;
  gridEl.style.pointerEvents = 'none';
  const snapshot = tiles.slice();
  solverWorker = new Worker(workerUrl);
  solverWorker.onmessage = function(ev){
    const data = ev.data;
    const moves = data.moves;
    if(!moves){
      solveBtn.disabled = false;
      gridEl.style.pointerEvents = '';
      solverRunning = false;
      let msg = 'Solver failed or timed out.';
      if(data && data.method){
        if(data.method.startsWith('4x4_stage1_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡ßß-‡ß¨ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('4x4_stage2_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage1_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡ßß‡¶Æ ‡ßß‡ß®‡¶ü‡¶æ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage2_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else msg = 'Solver could not finish (method: '+data.method+').';
      }
      alert(msg);
      if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
      return;
    }
    applyMovesSequence(moves);
  };
  solverWorker.postMessage({type:'solve', state: snapshot, size});
}

function stopSolverNow(){
  if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
  solverRunning = false;
  solveBtn.disabled = false;
  gridEl.style.pointerEvents = '';
  queuedMoves = [];
}

function applyMovesSequence(moves){
  let i = 0;
  queuedMoves = moves;
  const delay = 340;
  function step(){
    if(i >= moves.length){
      stopSolverNow();
      if(isSolved(tiles)) modalOverlay.style.display = 'flex';
      updateProgressBar();
      return;
    }
    const val = moves[i];
    const tile = [...gridEl.children].find(t => +t.dataset.number === val);
    if(tile) tryMove(tile);
    i++;
    updateProgressBar();
    setTimeout(step, delay);
  }
  setTimeout(step, 200);
}
solveBtn.addEventListener('click', startSolver);
window.addEventListener('keydown', (e)=>{
  if((e.key === 'b' || e.key === 'B') && !gameContainer.classList.contains('hidden')) startSolver();
  if(e.key === 'Escape' && solverRunning) stopSolverNow();
});
window.addEventListener('beforeunload', ()=>{ if(solverWorker) solverWorker.terminate(); });

/* typing effect (safe) */
(function(){
  const subTextEl = document.getElementById('thinking-subtext');
  const messages = [
    'Analyzing heuristics...',
    'Evaluating board...',
    'Preparing move...',
    '‡¶¨‡¶ü ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá...'
  ];
  let idx = 0;
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function typeEffect(text, element, delay=30) {
    if(!element){ await wait(700); return; }
    element.textContent = '';
    for(let i=0;i<text.length;i++){ element.textContent += text.charAt(i); await wait(delay); }
    await wait(800);
  }
  async function loopMessages() {
    while(true){ await typeEffect(messages[idx], subTextEl); idx = (idx + 1) % messages.length; }
  }
  loopMessages();
})();

/* ---------------- Firebase init & helpers ---------------- */
function stateKey(arr){ return arr.map(v=>v===null?'_':v).join(','); }
const firebaseApps = { a: null, b: null, c: null };
function initFirebaseApps(){
  try{
    if(typeof firebase === 'undefined') return;
    if(config1 && !firebaseApps.a){ firebaseApps.a = firebase.initializeApp(config1, 'app1'); }
    if(config2 && !firebaseApps.b){ firebaseApps.b = firebase.initializeApp(config2, 'app2'); }
    if(config3 && !firebaseApps.c){ firebaseApps.c = firebase.initializeApp(config3, 'app3'); }
  }catch(e){ console.warn('Firebase init error', e); }
}
function getDbForTile(tile){
  if(tile>=1 && tile<=8) return firebaseApps.a ? firebaseApps.a.database() : null;
  if(tile>=9 && tile<=16) return firebaseApps.b ? firebaseApps.b.database() : null;
  if(tile>=17 && tile<=24) return firebaseApps.c ? firebaseApps.c.database() : null;
  return null;
}

/* ---------------- Custom selectors & helpers ---------------- */
function populateCustomSelectors(){
  if(!size) return;
  tileSelect.innerHTML = '';
  for(let t=1; t<=size*size-1; t++){ const opt=document.createElement('option'); opt.value=t; opt.textContent=t; tileSelect.appendChild(opt); }
  rowSelect.innerHTML = '';
  for(let r=1; r<=size; r++){ const o=document.createElement('option'); o.value=r; o.textContent=r; rowSelect.appendChild(o); }
  colSelect.innerHTML = '';
  for(let c=1; c<=size; c++){ const o=document.createElement('option'); o.value=c; o.textContent=c; colSelect.appendChild(o); }
}

function refreshGridFromTiles(){
  gridEl.innerHTML = '';
  tiles.forEach((num,i)=>{
    if(num===null) return;
    const tile = document.createElement('div');
    tile.className = 'tile';
    if(currentMode==='hard') tile.classList.add('hard');
    tile.textContent = num;
    const {x,y} = getTranslate(i);
    tile.style.transform = `translate(${x}px,${y}px)`;
    tile.dataset.number = num;
    tile.dataset.position = i;
    gridEl.appendChild(tile);
  });
  emptyIndex = tiles.indexOf(null);
  updateProgressBar();
}

/* Apply button: swap tile into target row/col */
applyBtn.addEventListener('click', ()=>{
  const tnum = Number(tileSelect.value);
  const r = Number(rowSelect.value);
  const c = Number(colSelect.value);
  if(!tnum || !r || !c){ alert('Tile, Row ‡¶ì Column ‡¶†‡¶ø‡¶ï‡¶≠‡¶æ‡¶¨‡ßá ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®‡•§'); return; }
  const targetIdx = (r-1)*size + (c-1);
  const fromIdx = tiles.indexOf(tnum);
  if(fromIdx === -1){ alert('‡¶ü‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶¨‡ßã‡¶∞‡ßç‡¶°‡ßá ‡¶®‡ßá‡¶á‡•§'); return; }
  if(fromIdx === targetIdx){ alert('‡¶ü‡¶æ‡¶á‡¶≤‡¶ü‡¶ø ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá‡¶á ‡¶ê ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßá ‡¶Ü‡¶õ‡ßá‡•§'); return; }
  const temp = tiles[targetIdx];
  tiles[targetIdx] = tnum;
  tiles[fromIdx] = temp;
  emptyIndex = tiles.indexOf(null);
  refreshGridFromTiles();
});

/* ---------- Compute behavior: show card, estimate time, start worker, save special movedTiles ---------- */

function showComputeCardOverlay(tile, posIdx, movesArray, estimateSec){
  metaTile.textContent = tile;
  metaPos.textContent = posIdx;
  movesList.innerHTML = '';
  if(movesArray && movesArray.length){
    for(const m of movesArray){
      const el = document.createElement('div'); el.className='pill'; el.textContent = m; movesList.appendChild(el);
    }
  } else {
    const el = document.createElement('div'); el.style.color='#9fb3c8'; el.textContent = 'Computing...'; movesList.appendChild(el);
  }
  movedTilesWrap.innerHTML = '';
  saveStatus.textContent = 'Not saved yet';
  if(typeof estimateSec === 'number'){
    estimateText.textContent = `Estimated compute time: ~${estimateSec} s (heuristic)`;
  } else {
    estimateText.textContent = 'Estimated compute time: -';
  }
  computeCardOverlay.style.display = 'flex';
  // blur/dim the appWrap (not the overlay)
  appWrap.classList.add('dim');
}
function hideComputeCardOverlay(){
  computeCardOverlay.style.display = 'none';
  appWrap.classList.remove('dim');
}
cardClose.addEventListener('click', hideComputeCardOverlay);
computeCardOverlay.addEventListener('click', (e)=>{ if(e.target.id === 'computeBackdrop') hideComputeCardOverlay(); });

/* estimate compute time heuristic (manhattan distance * factor) */
function estimateComputeSeconds(snapshot, tile){
  const idx = snapshot.indexOf(tile);
  if(idx === -1) return 2;
  const r = Math.floor(idx/size), c = idx%size;
  const goalR = Math.floor((tile-1)/size), goalC = (tile-1)%size;
  const man = Math.abs(r-goalR)+Math.abs(c-goalC);
  // heuristic: 0.25s per manhattan + 0.6s base, cap 60s
  const ms = Math.min(60000, Math.round(man * 300 + 600));
  return Math.max(1, Math.ceil(ms/1000));
}

/* Compute button handler: show overlay, estimate, spawn worker, save result + special movedTiles for tile1 bottom-right */
computeBtn.addEventListener('click', async ()=>{
  const tnum = Number(tileSelect.value);
  if(!tnum){ alert('‡¶è‡¶ï‡¶ü‡¶ø Tile ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®‡•§'); return; }
  const snapshot = tiles.slice();
  const originalIdx = snapshot.indexOf(tnum);

  // show initial card with estimate
  const est = estimateComputeSeconds(snapshot, tnum);
  showComputeCardOverlay(tnum, originalIdx, null, est);

  initFirebaseApps();
  const w = new Worker(workerUrl);
  w.onmessage = function(ev){
    const d = ev.data;
    if(d.type === 'compute_result'){
      const moves = d.moves || [];
      // update card moves
      movesList.innerHTML = '';
      if(moves.length){
        for(const m of moves){
          const el = document.createElement('div'); el.className='pill'; el.textContent = m; movesList.appendChild(el);
        }
      } else {
        const el = document.createElement('div'); el.style.color='#9fb3c8'; el.textContent = 'No moves found / timed out'; movesList.appendChild(el);
      }
      // compute movedTiles set
      const movedSet = new Set((moves||[]).map(x=>x));
      const movedArr = Array.from(movedSet);
      movedTilesWrap.innerHTML = '';
      if(movedArr.length){
        const lbl = document.createElement('div'); lbl.style.color='#9fb3c8'; lbl.textContent = 'Moved tiles in this compute:';
        movedTilesWrap.appendChild(lbl);
        const wrap = document.createElement('div'); wrap.style.marginTop='6px'; movedTilesWrap.appendChild(wrap);
        for(const mv of movedArr){
          const p = document.createElement('span'); p.className='pill'; p.style.marginRight='6px'; p.textContent = mv; wrap.appendChild(p);
        }
      }

      // Save to firebase path if db available
      const db = getDbForTile(d.target);
      if(!db){
        saveStatus.textContent = 'Firebase not configured for this tile range.';
        w.terminate();
        return;
      }
      const key = stateKey(snapshot);
      const path = `tiles/${d.target}/${encodeURIComponent(key)}`;
      const ref = db.ref(path);

      // Special feature: if tile==1 and its ORIGINAL position was bottom-right of board (index size*size-1), save movedTiles field
      const specialSaveExtra = (d.target === 1 && originalIdx === size*size-1) ? { movedTiles: movedArr } : {};

      ref.get().then(snap=>{
        if(snap.exists()){
          saveStatus.textContent = 'Already saved (cached).';
        } else {
          const payload = { moves: moves || [], length: moves?moves.length:0, timestamp: Date.now(), ...specialSaveExtra };
          ref.set(payload).then(()=>{
            saveStatus.textContent = 'Saved ‚úÖ';
          }).catch(e=>{
            saveStatus.textContent = 'Save failed: '+e.message;
          });
        }
      }).catch(err=>{
        saveStatus.textContent = 'DB check failed: '+err.message;
      });

      w.terminate();
    }
  };
  w.postMessage({type:'compute_tile', state: snapshot, size, targetTile: tnum});
});

/* manual save from card (if user wants) */
cardSave.addEventListener('click', ()=>{
  const t = Number(metaTile.textContent);
  if(!t || isNaN(t)){ alert('No target tile in card'); return; }
  const db = getDbForTile(t);
  if(!db){ alert('Firebase not configured for this tile range.'); return; }
  const snapshot = tiles.slice();
  const key = stateKey(snapshot);
  const path = `tiles/${t}/${encodeURIComponent(key)}`;
  db.ref(path).get().then(snap=>{
    if(snap.exists()){ saveStatus.textContent = 'Already saved (cached).'; }
    else{
      const moves = Array.from(movesList.children).map(c=>c.textContent).filter(Boolean);
      db.ref(path).set({ moves: moves, length: moves.length, timestamp: Date.now() }).then(()=>{ saveStatus.textContent = 'Saved ‚úÖ'; }).catch(e=>{ saveStatus.textContent = 'Save failed: '+e.message; });
    }
  }).catch(err=>{ saveStatus.textContent = 'DB check failed: '+err.message; });
});

/* toggle custom UI etc */
setCustomBtn.addEventListener('click', ()=>{ customWrapper.style.display = (customWrapper.style.display === 'block')? 'none' : 'block'; });
computeInfoBtn.addEventListener('click', ()=>{ computeInfoOverlay.style.display = 'flex'; });
closeInfoBtn && closeInfoBtn.addEventListener('click', ()=>{ computeInfoOverlay.style.display = 'none'; });
computeInfoOverlay.addEventListener('click', (e)=>{ if(e.target === computeInfoOverlay) computeInfoOverlay.style.display='none'; });

/* populate selectors once grid created; user can call createGrid by Start Game */
/* End of script */
</script>
</body>
</html>
