<!DOCTYPE html>
<html lang="bn" class="scroll-smooth">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Puzzle — Solver (Stages+Progress+URL)</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat SDKs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>

  <style>
    body { background:#0d1117; color:#c9d1d9; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #homeScreen,#gameContainer { background:#161b22cc; box-shadow:0 8px 24px rgba(12,17,23,0.6); }
    #toggleSlider { background:#238636; }
    .tile {
      position:absolute;
      width: calc(100% / var(--grid-size) - 0.75rem);
      height: calc(100% / var(--grid-size) - 0.75rem);
      display:flex; align-items:center; justify-content:center;
      border-radius:0.5rem; cursor:pointer; user-select:none;
      font-size:2.5rem; font-weight:800; color:#e1e4e8;
      background:linear-gradient(145deg,#3a3f4b,#2c303a);
      box-shadow:0 6px 12px rgba(0,0,0,0.8), inset 0 3px 6px rgba(255,255,255,0.05);
      transition: transform 0.25s ease;
      text-shadow:0 0 4px #0008; backface-visibility:hidden;
    }
    .tile.hard { font-size:1.5rem; }
    .tile:hover { background:linear-gradient(145deg,#2c5f37,#1f3f22); color:#7fffd4; box-shadow:0 10px 20px rgba(35,134,54,0.7), inset 0 3px 7px rgba(255,255,255,0.15); transform:scale(1.06) var(--translate); z-index:10; text-shadow:0 0 8px #7fffd4cc; }
    .tile.empty { background:transparent; box-shadow:none; cursor:default; pointer-events:none; }
    #grid { position:relative; width:100%; height:100%; --grid-size:3; }
    #modalOverlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); align-items:center; justify-content:center; z-index:100; }
    #modal { background:#21262d; padding:2rem; border-radius:1rem; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.7); }
    #modal h2 { font-size:2rem; margin-bottom:1rem; color:#58a6ff; }
    #modal button { margin-top:1rem; padding:0.75rem 1.5rem; background:#238636; color:white; border:none; border-radius:0.5rem; font-size:1rem; cursor:pointer; transition:background 0.2s; }
    #modal button:hover { background:#2ea043; }
    #controls { width:100%; max-width:40rem; margin-top:36px; display:none; flex-direction:column; gap:12px; align-items:center; }
    #solveBtn, #customBtn, #openHelpBtn {
      padding:0.72rem 1.2rem; border-radius:0.75rem; font-size:1.05rem; font-weight:700;
      cursor:pointer; background:#16a34a; color:white; border:none; box-shadow:0 8px 20px rgba(0,0,0,0.6);
      transition: background .15s, transform .08s; width:100%;
    }
    #solveBtn:hover, #customBtn:hover, #openHelpBtn:hover{ background:#169e43; transform:translateY(-2px); }
    #solveBtn:disabled{ background:#285c38; cursor:not-allowed; opacity:.85; transform:translateY(0); }
    #thinkingSmall { display:block; margin-top:6px; font-size:0.85em; color:#ddd; }
    #thinking-container {
      width:100%;
      margin: 10px auto 8px auto;
      padding: 18px 22px;
      background-color: #202124;
      border-radius: 14px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.1), 0 1px 3px rgba(0,0,0,0.4);
      color: #e8eaed;
      user-select: none;
    }
    #thinking-text {
      font-size: 1.3rem;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      display: inline-block;
      white-space: nowrap;
      background: linear-gradient(90deg,#e8eaed 20%,#121212 40%,#e8eaed 60%);
      background-repeat: no-repeat;
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shine-slide 2.5s linear infinite;
    }
    @keyframes shine-slide {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    #thinking-subtext { margin-top: 10px; font-style: italic; color: #c7c7c7; min-height: 22px; font-size: .95rem; }
    /* Progress Bar */
    #progressBarWrap {
      width:100%; max-width:34rem; margin:14px auto 0 auto;
      background:#23272e; border-radius:0.7rem; height:1.1rem; box-shadow:0 2px 8px #0005;
      overflow:hidden; position:relative;
    }
    #progressBar { height:100%; background:linear-gradient(90deg,#238636,#58a6ff); width:0%; transition:width 0.5s; }
    #progressText {
      position:absolute; left:0; right:0; top:0; bottom:0; display:flex;
      align-items:center; justify-content:center; font-size:.9rem; color:#fff; font-weight:700;
      text-shadow:0 2px 8px #0009; pointer-events:none;
    }
    /* Custom Position Panel */
    #customPanel { display:none; width:100%; background:#1b1f27; border:1px solid #2b3240; border-radius:14px; padding:14px; }
    .field { display:flex; align-items:center; gap:10px; margin:8px 0; }
    .field label { min-width:90px; color:#9aa4af; font-weight:600; }
    .field input { width:80px; background:#0f1320; color:#e1e7ef; border:1px solid #2b3240; border-radius:10px; padding:10px 12px; outline:none; }
    .field input:focus { border-color:#4b92ff; }
    #customActions { display:flex; gap:10px; align-items:center; }
    #applyCustom, #computeCustom { background:#2563eb; border:none; color:white; padding:10px 14px; border-radius:10px; font-weight:700; cursor:pointer; }
    #computeCustom { background:#8b5cf6; }
    #applyCustom:hover { background:#1d4ed8; }
    #computeCustom:hover { background:#7c3aed; }
    #openHelpBtn { background:#374151; }
    /* Compute Overlay */
    #overlayDim {
      display:none; position:fixed; inset:0; background:rgba(0,0,0,0.55); backdrop-filter: blur(3px);
      z-index:200;
    }
    #computeCard {
      display:none; position:fixed; left:50%; top:8%; transform:translateX(-50%);
      width: min(92vw, 560px); background:#111827; border:1px solid #374151; border-radius:18px; padding:18px 18px 14px 18px; z-index:210;
      box-shadow: 0 10px 40px rgba(0,0,0,.6);
    }
    #computeCard h3 { font-size:1.15rem; font-weight:800; color:#93c5fd; margin-bottom:8px; }
    #computeCard pre { background:#0b1220; color:#e5e7eb; padding:12px; border-radius:12px; max-height:200px; overflow:auto; font-size:.9rem; }
    #computeCard .row { display:flex; justify-content:space-between; align-items:center; gap:8px; margin:6px 0; }
    #computeCard .pill { background:#0f172a; border:1px solid #1f2937; padding:6px 10px; border-radius:999px; font-size:.85rem; color:#e5e7eb; }
    #computeCard .btn { background:#22c55e; color:#0b1220; font-weight:800; border:none; border-radius:10px; padding:10px 14px; cursor:pointer; }
    #computeCard .btn:hover { filter:brightness(1.05); }
    #computeCard .btn.secondary { background:#374151; color:#e5e7eb; }
    #computeCard .status { font-size:.9rem; color:#d1fae5; }
    #blurScope.blurred *:not(#overlayDim):not(#computeCard):not(#computeCard *){
      filter: blur(1.2px); transition: filter .15s ease;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-6" id="blurScope">

  <!-- Home -->
  <div id="homeScreen" class="w-full max-w-md p-8 rounded-3xl text-center mb-10 select-none">
    <h1 class="text-white text-5xl font-extrabold mb-8 drop-shadow-lg">Sliding Puzzle Game</h1>
    <div class="relative inline-block w-full bg-gray-800 rounded-full overflow-hidden shadow-inner">
      <div id="toggleSlider" class="absolute top-0 left-0 rounded-full h-full w-1/3 transition-all duration-300 ease-in-out"></div>
      <div class="flex text-gray-300 font-semibold text-xl cursor-pointer">
        <div data-mode="easy" class="flex-1 py-4 z-10">Easy</div>
        <div data-mode="normal" class="flex-1 py-4 z-10">Normal</div>
        <div data-mode="hard" class="flex-1 py-4 z-10">Hard</div>
      </div>
    </div>
    <button id="startBtn" class="mt-10 w-full bg-green-600 hover:bg-green-700 text-white py-4 rounded-2xl text-2xl font-semibold shadow-lg transition duration-300">
      Start Game
    </button>
    <p class="text-sm text-gray-400 mt-3">গেম শুরু হলে নিচের <strong>Solve</strong> বাটন দিয়ে বট চালাও (বা কীবোর্ডে <strong>B</strong> চাপতে পারো)।</p>
  </div>

  <!-- Game container -->
  <div id="gameContainer" class="hidden w-full max-w-lg aspect-square rounded-3xl p-6 flex flex-col relative">
    <div id="grid"></div>
  </div>

  <!-- Progress bar -->
  <div id="progressBarWrap" style="display:none;">
    <div id="progressBar"></div>
    <div id="progressText"></div>
  </div>

  <!-- Controls below board (hidden on home) -->
  <div id="controls">
    <div id="thinkingSmall" aria-hidden="true"></div>
    <div id="winner-message"></div>
    <div id="game-board"></div>

    <!-- Stages box -->
    <div id="thinking-container" role="status" aria-live="polite" aria-atomic="true" aria-label="Bot thinking status">
      <div id="thinking-text">Solving With Stages...</div>
      <div id="thinking-subtext"></div>
    </div>

    <!-- Solve button (same width as stages) -->
    <button id="solveBtn" title="Bot Solve">Solve</button>

    <!-- Set custom position -->
    <button id="customBtn" title="Set a custom tile position">Set Custom Position</button>
    <div id="customPanel">
      <div class="field">
        <label>Tile</label>
        <input id="tileInput" type="number" min="1" max="24" value="1" />
      </div>
      <div class="field">
        <label>Row</label>
        <input id="rowInput" type="number" min="1" max="5" value="5" />
      </div>
      <div class="field">
        <label>Column</label>
        <input id="colInput" type="number" min="1" max="5" value="5" />
      </div>
      <div id="customActions">
        <button id="applyCustom">Apply</button>
        <button id="computeCustom">Compute</button>
        <button id="openHelpBtn">What is this?</button>
      </div>
    </div>
  </div>

  <!-- Win Modal -->
  <div id="modalOverlay" class="hidden items-center justify-center">
    <div id="modal">
      <h2>🎉 You Solved It!</h2>
      <p class="text-gray-300">Congratulations on completing the puzzle.</p>
      <button id="closeModal">Close</button>
    </div>
  </div>

  <!-- Dimming overlay + compute card -->
  <div id="overlayDim"></div>
  <div id="computeCard" role="dialog" aria-modal="true" aria-label="Compute Result">
    <div class="row" style="margin-bottom:6px;">
      <h3>Compute Result</h3>
      <span id="estTime" class="pill">Estimated compute time: ~—</span>
    </div>
    <div class="row">
      <span class="pill" id="cardTileInfo">Tile: — • Pos: —</span>
      <span class="pill" id="cardStatus">Not saved yet</span>
    </div>
    <div class="row">
      <div style="font-weight:800; color:#a7f3d0;">Moves:</div>
    </div>
    <pre id="movesPre">Computing...</pre>
    <div class="row" id="movedTilesRow" style="display:none;">
      <div class="pill">Moved tiles in this compute:</div>
      <div id="movedTilesList" class="pill"></div>
    </div>
    <div class="row" style="margin-top:8px;">
      <button class="btn" id="saveToDbBtn">Save to Firebase</button>
      <button class="btn secondary" id="closeCardBtn">Close</button>
    </div>
  </div>

  <script>
    // ==================== FIREBASE: 3 APPS INIT + ANON AUTH ====================
    const configA = {
      apiKey: "AIzaSyCMEqtaxOodPnwMKkrSVZrcjLMmj3oefB0",
      authDomain: "chatstudio-agent.firebaseapp.com",
      databaseURL: "https://chatstudio-agent-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "chatstudio-agent",
      storageBucket: "chatstudio-agent.firebasestorage.app",
      messagingSenderId: "626338448826",
      appId: "1:626338448826:web:67936971701c3466d90983",
      measurementId: "G-ZHNZHMYC0B"
    };
    const configB = {
      apiKey: "AIzaSyAKd2WmThKb4OM9pv0Bx9vtunmGpRGxczM",
      authDomain: "puzzle-solver-5-2.firebaseapp.com",
      databaseURL: "https://puzzle-solver-5-2-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "puzzle-solver-5-2",
      storageBucket: "puzzle-solver-5-2.firebasestorage.app",
      messagingSenderId: "221283910343",
      appId: "1:221283910343:web:0bef0b54fe26e594c8f4e2"
    };
    const configC = {
      apiKey: "AIzaSyDohgyc4pRldMVxbFRTkHnNfAIczf8JHMo",
      authDomain: "puzzle-solver-4-1.firebaseapp.com",
      databaseURL: "https://puzzle-solver-4-1-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "puzzle-solver-4-1",
      storageBucket: "puzzle-solver-4-1.firebasestorage.app",
      messagingSenderId: "422133823015",
      appId: "1:422133823015:web:0daf2ce34fa8fe98eac002"
    };

    const firebaseApps = { a:null, b:null, c:null };
    async function initFirebaseApps(){
      if(typeof firebase === 'undefined') return;
      try {
        if(!firebaseApps.a){
          firebaseApps.a = firebase.initializeApp(configA, "appA");
          firebaseApps.a.db = firebaseApps.a.database();
          firebaseApps.a.auth = firebase.auth(firebaseApps.a);
          try{ await firebaseApps.a.auth.signInAnonymously(); }catch(e){ console.warn('appA anon auth failed', e); }
        }
        if(!firebaseApps.b){
          firebaseApps.b = firebase.initializeApp(configB, "appB");
          firebaseApps.b.db = firebaseApps.b.database();
          firebaseApps.b.auth = firebase.auth(firebaseApps.b);
          try{ await firebaseApps.b.auth.signInAnonymously(); }catch(e){ console.warn('appB anon auth failed', e); }
        }
        if(!firebaseApps.c){
          firebaseApps.c = firebase.initializeApp(configC, "appC");
          firebaseApps.c.db = firebaseApps.c.database();
          firebaseApps.c.auth = firebase.auth(firebaseApps.c);
          try{ await firebaseApps.c.auth.signInAnonymously(); }catch(e){ console.warn('appC anon auth failed', e); }
        }
      } catch(e){
        console.warn('Firebase init error', e);
      }
    }
    initFirebaseApps();

    function dbForTile(tile){
      if(tile>=1 && tile<=8) return firebaseApps.a && firebaseApps.a.db;
      if(tile>=9 && tile<=16) return firebaseApps.b && firebaseApps.b.db;
      if(tile>=17 && tile<=24) return firebaseApps.c && firebaseApps.c.db;
      return null;
    }
    function stateKeyForTilePosition(tile, posIdx){
      // Simple key by position index of that tile (0..24)
      return `tile_${tile}_pos_${posIdx}`;
    }

    // ==================== UI / GAME STATE ====================
    const modes = { easy:{size:3, path:'easy'}, normal:{size:4, path:'normal'}, hard:{size:5, path:'hard'} };
    let currentMode = 'easy';
    const homeScreen = document.getElementById('homeScreen');
    const gameContainer = document.getElementById('gameContainer');
    const gridEl = document.getElementById('grid');
    const toggleSlider = document.getElementById('toggleSlider');
    const startBtn = document.getElementById('startBtn');
    const modalOverlay = document.getElementById('modalOverlay');
    const closeModal = document.getElementById('closeModal');
    const controls = document.getElementById('controls');
    const solveBtn = document.getElementById('solveBtn');
    const customBtn = document.getElementById('customBtn');
    const customPanel = document.getElementById('customPanel');
    const tileInput = document.getElementById('tileInput');
    const rowInput = document.getElementById('rowInput');
    const colInput = document.getElementById('colInput');
    const applyCustom = document.getElementById('applyCustom');
    const computeCustom = document.getElementById('computeCustom');
    const openHelpBtn = document.getElementById('openHelpBtn');

    // Progress bar
    const progressBarWrap = document.getElementById('progressBarWrap');
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');

    // Overlay elements
    const overlayDim = document.getElementById('overlayDim');
    const computeCard = document.getElementById('computeCard');
    const estTimeEl = document.getElementById('estTime');
    const cardTileInfo = document.getElementById('cardTileInfo');
    const cardStatus = document.getElementById('cardStatus');
    const movesPre = document.getElementById('movesPre');
    const movedTilesRow = document.getElementById('movedTilesRow');
    const movedTilesList = document.getElementById('movedTilesList');
    const saveToDbBtn = document.getElementById('saveToDbBtn');
    const closeCardBtn = document.getElementById('closeCardBtn');

    let size, tiles = [], emptyIndex;
    let solverWorker = null, solverRunning = false, queuedMoves = [];

    // Mode switch with URL update
    document.querySelectorAll('[data-mode]').forEach(el=>{
      el.addEventListener('click', ()=> {
        currentMode = el.dataset.mode;
        const idx = ['easy','normal','hard'].indexOf(currentMode);
        toggleSlider.style.left = `${idx*33.3333}%`;
        const p = modes[currentMode].path;
        if(location.pathname!=="/"+p) history.replaceState({}, '', "/"+p);
      });
    });

    // Set URL mode on load
    (function setModeFromUrl(){
      const path = location.pathname.replace(/^\//,'');
      if(path && Object.values(modes).some(m=>m.path===path)){
        currentMode = Object.keys(modes).find(k=>modes[k].path===path) || "easy";
      }
      const idx = ['easy','normal','hard'].indexOf(currentMode);
      toggleSlider.style.left = `${idx*33.3333}%`;
    })();

    function idxFromRC(r,c){ return r*size + c; }
    function rcFromIdx(i){ return { r: Math.floor(i/size), c: i%size }; }

    function getTranslate(index){
      const row = Math.floor(index/size), col = index%size;
      const tileSize = gridEl.clientWidth/size;
      return { x: col*tileSize, y: row*tileSize };
    }

    function createGrid(gridSize){
      size = gridSize;
      gridEl.style.setProperty('--grid-size', size);
      gridEl.innerHTML = '';
      tiles = Array.from({length:size*size-1},(_,i)=>i+1);
      tiles.push(null);
      shuffleTiles(tiles,size);
      emptyIndex = tiles.indexOf(null);

      tiles.forEach((num,i)=>{
        if(num===null) return;
        const tile = document.createElement('div');
        tile.className = 'tile';
        if(currentMode==='hard') tile.classList.add('hard');
        tile.textContent = num;
        const {x,y} = getTranslate(i);
        tile.style.transform = `translate(${x}px,${y}px)`;
        tile.dataset.number = num;
        tile.dataset.position = i;
        gridEl.appendChild(tile);
      });
      controls.style.display = 'flex';
      progressBarWrap.style.display = 'block';
      updateProgressBar();
    }

    function shuffleTiles(arr,s){
      do{
        for(let i=arr.length-1;i>0;i--){
          const j = Math.floor(Math.random()*(i+1));
          [arr[i],arr[j]]=[arr[j],arr[i]];
        }
      }while(!isSolvable(arr,s)||isSolved(arr));
    }

    function isSolvable(arr,s){
      let inv=0, flat=arr.filter(x=>x!==null);
      for(let i=0;i<flat.length;i++)
        for(let j=i+1;j<flat.length;j++)
          if(flat[i]>flat[j]) inv++;
      if(s%2) return inv%2===0;
      const er = Math.floor(arr.indexOf(null)/s);
      return er%2?inv%2===0:inv%2!==0;
    }

    function isSolved(arr){
      for(let i=0;i<arr.length-1;i++) if(arr[i]!==i+1) return false;
      return arr[arr.length-1]===null;
    }

    function tryMove(tile){
      const tilePos = +tile.dataset.position;
      const emptyPos = emptyIndex;
      const r1 = Math.floor(tilePos/size), c1 = tilePos%size;
      const r2 = Math.floor(emptyPos/size), c2 = emptyPos%size;
      const adj = (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
      if(!adj) return false;
      [tiles[tilePos],tiles[emptyPos]]=[tiles[emptyPos],tiles[tilePos]];
      const {x,y} = getTranslate(emptyPos);
      tile.style.transform = `translate(${x}px,${y}px)`;
      tile.dataset.position = emptyPos;
      emptyIndex = tilePos;
      updateProgressBar();
      return true;
    }

    gridEl.addEventListener('click', e=>{
      const tile = e.target.closest('.tile');
      if(!tile) return;
      if(tryMove(tile) && isSolved(tiles)){
        modalOverlay.classList.remove('hidden');
        updateProgressBar();
      }
    });

    startBtn.addEventListener('click', ()=>{
      homeScreen.classList.add('hidden');
      gameContainer.classList.remove('hidden');
      createGrid(modes[currentMode].size);
    });

    closeModal.addEventListener('click', ()=>{ modalOverlay.classList.add('hidden'); });

    window.addEventListener('resize', ()=>{
      tiles.forEach(num=>{
        if(num===null) return;
        const tile = [...gridEl.children].find(t=>+t.dataset.number===num);
        if(!tile) return;
        const {x,y} = getTranslate(+tile.dataset.position);
        tile.style.transform = `translate(${x}px,${y}px)`;
      });
    });

    // Progress bar calculation
    function calcProgress(arr, sz){
      if(sz===3) {
        let cnt=0;
        for(let i=0;i<8;i++) if(arr[i]===i+1) cnt++;
        return Math.round(cnt/8*100);
      }
      if(sz===4) {
        let cnt=0;
        for(let i=0;i<15;i++) if(arr[i]===i+1) cnt++;
        return Math.round(cnt/15*100);
      }
      if(sz===5){
        let stage1=0, total=0;
        const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
        for(const i of st1idx) if(arr[i]===i+1) stage1++;
        for(let i=0;i<24;i++) if(arr[i]===i+1) total++;
        return Math.round((stage1/12*70)+(total/24*30));
      }
      return 0;
    }

    function updateProgressBar(){
      if(!tiles||!size) return;
      const perc = calcProgress(tiles,size);
      progressBar.style.width = perc+"%";
      progressText.textContent = perc+"% solved";
      if(perc===100) progressText.textContent = "🎉 Puzzle Solved!";
    }

    // ==================== ORIGINAL SOLVER (3x3/4x4) — UNCHANGED ====================
    function solverWorkerFunction(){
      self.onmessage = function(ev){
        try{
          const {type, state, size} = ev.data;
          if(type !== 'solve') return;
          const startState = state.slice();

          function idxToRC(i){ return {r: Math.floor(i/size), c: i%size}; }
          const goalPos = {}; for(let v=1; v<=size*size-1; v++) goalPos[v] = idxToRC(v-1);

          function manhattanUnfixed(arr, fixedSet){
            let s = 0;
            for(let i=0;i<arr.length;i++){
              const v = arr[i]; if(v==null) continue;
              const gi = v-1; if(fixedSet && fixedSet.has(gi)) continue;
              const cur = idxToRC(i), g = goalPos[v];
              if(!g) continue;
              s += Math.abs(cur.r - g.r) + Math.abs(cur.c - g.c);
            }
            return s;
          }

          function neighborsOfEmpty(emptyIdx){
            const res=[];
            const r=Math.floor(emptyIdx/size), c=emptyIdx%size;
            const deltas=[{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
            for(const d of deltas){
              const nr=r+d.dr, nc=c+d.dc;
              if(nr>=0 && nr<size && nc>=0 && nc<size) res.push(nr*size+nc);
            }
            return res;
          }

          function bfsPlaceTile(currentState, fixedSet, targetVal, targetGoalIdx){
            const start = currentState.slice();
            const startEmpty = start.indexOf(null);
            const key = s => s.map(x=>x===null?'_':x).join(',');
            const Queue = [];
            const Seen = new Set();
            Queue.push({arr:start.slice(), empty:startEmpty, path:[]});
            Seen.add(key(start));
            const maxNodes = 200_000;
            let nodes=0;
            const maxDepth = 40;
            while(Queue.length){
              const node = Queue.shift();
              nodes++;
              if(nodes > maxNodes) break;
              if(node.arr[targetGoalIdx] === targetVal) return node.path.slice();
              if(node.path.length >= maxDepth) continue;
              const neigh = neighborsOfEmpty(node.empty);
              for(const idx of neigh){
                if(fixedSet.has(idx)) continue;
                const newA = node.arr.slice();
                newA[node.empty] = newA[idx];
                newA[idx] = null;
                const k = key(newA);
                if(Seen.has(k)) continue;
                Seen.add(k);
                const newPath = node.path.slice(); newPath.push(newA[node.empty]);
                Queue.push({arr:newA, empty: idx, path:newPath});
              }
            }
            return null;
          }

          function idaFull(initial, nodeCap=5_000_000, tCap=30_000){
            const state = initial.slice();
            let empty = state.indexOf(null);
            let nodes=0;
            function h(){ return manhattanUnfixed(state, new Set()); }
            let threshold = h();
            const path=[];
            let found=null;
            function dfs(eidx, g, prev){
              nodes++;
              if(nodes>nodeCap) return Infinity;
              const hv = manhattanUnfixed(state, new Set());
              const f = g + hv;
              if(f > threshold) return f;
              if(hv===0){ found = path.slice(); return 'FOUND'; }
              let min=Infinity;
              const neigh = neighborsOfEmpty(eidx);
              const order = neigh.map(idx=>{
                const val = state[idx];
                state[eidx]=val; state[idx]=null;
                const hv2 = manhattanUnfixed(state, new Set());
                state[idx]=val; state[eidx]=null;
                return {idx,hv2};
              }).sort((a,b)=>a.hv2-b.hv2);
              for(const o of order){
                const ti=o.idx;
                if(prev !== undefined && ti===prev) continue;
                const v = state[ti];
                state[eidx]=v; state[ti]=null;
                path.push(v);
                const r = dfs(ti, g+1, eidx);
                if(r==='FOUND') return 'FOUND';
                if(r < min) min = r;
                path.pop();
                state[ti]=v; state[eidx]=null;
              }
              return min;
            }
            const t0 = Date.now();
            while(true){
              nodes=0;
              const r = dfs(empty, 0, undefined);
              if(r==='FOUND') { self.postMessage({type:'done', moves:path.slice(), method:'ida_full'}); return; }
              if(r===Infinity || nodes>nodeCap) break;
              threshold = r;
              if(Date.now()-t0 > tCap) break;
            }
            self.postMessage({type:'done', moves:null, method:'ida_timeout'});
          }

          // 4x4: keep previous logic — stage-like then ida
          if(size === 4){
            const working = startState.slice();
            let allMoves = [];
            const fixedIndices = new Set();
            try{
              for(let c=0; c<size; c++){
                const targetVal = c+1;
                const goalIdx = c;
                if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
                let moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
                if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
                for(const mv of moves){
                  const fromIdx = working.indexOf(mv);
                  const eIdx = working.indexOf(null);
                  working[eIdx]=mv; working[fromIdx]=null;
                  allMoves.push(mv);
                }
                if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
                fixedIndices.add(goalIdx);
              }
              // second row sample
              for(let i=4;i<=5;i++){
                const targetVal = i+1;
                const goalIdx = i;
                if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
                let moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
                if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
                for(const mv of moves){
                  const fromIdx = working.indexOf(mv);
                  const eIdx = working.indexOf(null);
                  working[eIdx]=mv; working[fromIdx]=null;
                  allMoves.push(mv);
                }
                if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
                fixedIndices.add(goalIdx);
              }
              // rest: ida
              // send via idaFull call
              idaFull(working, 600000, 16000);
            }catch(e){
              self.postMessage({type:'done', moves:null, method:'4x4_exception', error:String(e)});
            }
            return;
          }
          if(size<=3){
            idaFull(startState);
            return;
          }
          // fallback
          idaFull(startState, 150000, 7000);
        }catch(e){
          self.postMessage({type:'done', moves:null, method:'worker_crash', error: String(e)});
        }
      };
    } // end original worker

    // ==================== 5x5 TARGET-FOCUSED A* WORKER (no IDA) ====================
    function computeWorkerFunction(){
      // A* only for a single target tile to reach its goal index; others can shuffle
      self.onmessage = function(ev){
        const { type, state, size, targetTile, goalIdx, nodeCap=250000, timeCapMs=4000 } = ev.data || {};
        if(type !== 'compute_tile') return;
        const start = state.slice();
        const N = size;
        const goalIndex = goalIdx;
        const t0 = Date.now();

        function keyOf(arr){ return arr.map(v=>v==null?'_':v).join(','); }
        function manhattanTarget(arr){
          const i = arr.indexOf(targetTile);
          const r = Math.floor(i/N), c = i%N;
          const gr = Math.floor(goalIndex/N), gc = goalIndex%N;
          return Math.abs(r-gr) + Math.abs(c-gc);
        }
        function neighbors(arr){
          const e = arr.indexOf(null);
          const r = Math.floor(e/N), c = e%N;
          const res = [];
          if(r>0) res.push(e-N);
          if(r<N-1) res.push(e+N);
          if(c>0) res.push(e-1);
          if(c<N-1) res.push(e+1);
          return res;
        }

        // A* with simple array-based PQ (kept small by caps)
        const startKey = keyOf(start);
        const open = [{ f: manhattanTarget(start), g:0, key:startKey, arr:start, empty:start.indexOf(null), path:[] }];
        const seen = new Map(); seen.set(startKey, 0);
        let best = null;
        let nodes=0;

        while(open.length){
          // pick min f
          open.sort((a,b)=>a.f-b.f);
          const cur = open.shift();
          nodes++;
          if(nodes>nodeCap || (Date.now()-t0)>timeCapMs) break;

          if(cur.arr[goalIndex] === targetTile){
            best = cur;
            break;
          }
          const neigh = neighbors(cur.arr);
          for(const nIdx of neigh){
            const newArr = cur.arr.slice();
            // slide tile at nIdx into empty
            newArr[cur.empty] = newArr[nIdx];
            newArr[nIdx] = null;
            const g2 = cur.g + 1;
            const k = keyOf(newArr);
            if(seen.has(k) && seen.get(k) <= g2) continue;
            seen.set(k, g2);
            const h = manhattanTarget(newArr);
            const f = g2 + h;
            const mv = newArr[cur.empty]; // which tile moved
            open.push({ f, g:g2, key:k, arr:newArr, empty:nIdx, path: cur.path.concat(mv) });
          }
        }

        if(best){
          // collect moved tiles set
          const movedSet = new Set(best.path);
          self.postMessage({
            type:'compute_result',
            target: targetTile,
            goalIndex,
            moves: best.path,
            movedTiles: Array.from(movedSet),
            explored: nodes,
            tookMs: Date.now()-t0
          });
        } else {
          self.postMessage({
            type:'compute_result',
            target: targetTile,
            goalIndex,
            moves: null,
            movedTiles: [],
            explored: nodes,
            tookMs: Date.now()-t0
          });
        }
      };
    } // end compute worker

    // Create workers
    const baseWorkerBlob = new Blob(['('+solverWorkerFunction.toString()+')()'], {type:'application/javascript'});
    const baseWorkerUrl = URL.createObjectURL(baseWorkerBlob);

    const computeWorkerBlob = new Blob(['('+computeWorkerFunction.toString()+')()'], {type:'application/javascript'});
    const computeWorkerUrl = URL.createObjectURL(computeWorkerBlob);

    // ==================== SOLVING / APPLY ====================
    function startSolver(){
      if(solverRunning) return;
      if(gameContainer.classList.contains('hidden')) return;
      solverRunning = true;
      solveBtn.disabled = true;
      gridEl.style.pointerEvents = 'none';
      const snapshot = tiles.slice();

      // For 5x5 → use our cache-first serial plan (1..24)
      if(size === 5){
        solve5x5SerialWithCache(snapshot).then(()=>{
          stopSolverNow();
          if(isSolved(tiles)) modalOverlay.classList.remove('hidden');
          updateProgressBar();
        }).catch(err=>{
          console.warn('5x5 solve error', err);
          stopSolverNow();
          alert('5×5 solver failed.');
        });
        return;
      }

      // others → original worker
      const w = new Worker(baseWorkerUrl);
      solverWorker = w;
      w.onmessage = function(ev){
        const data = ev.data;
        const moves = data.moves;
        if(!moves){
          solveBtn.disabled = false;
          gridEl.style.pointerEvents = '';
          solverRunning = false;
          let msg = 'Solver failed or timed out.';
          if(data && data.method){
            if(data.method.startsWith('4x4_stage1_fail')) msg="৪×৪ puzzle: ১-৬ tile stage-এ আটকে গেছে!";
            else if(data.method.startsWith('4x4_stage2_fail')) msg="৪×৪ puzzle: শেষ stage-এ আটকে গেছে!";
            else msg = 'Solver could not finish (method: '+data.method+').';
          }
          alert(msg);
          if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
          return;
        }
        applyMovesSequence(moves);
      };
      w.postMessage({type:'solve', state: snapshot, size});
    }

    function stopSolverNow(){
      if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
      solverRunning = false;
      solveBtn.disabled = false;
      gridEl.style.pointerEvents = '';
      queuedMoves = [];
    }

    function applyMovesSequence(moves, delay=300){
      let i = 0;
      queuedMoves = moves || [];
      function step(){
        if(i >= queuedMoves.length){
          updateProgressBar();
          return;
        }
        const val = queuedMoves[i];
        const tile = [...gridEl.children].find(t => +t.dataset.number === val);
        if(tile) tryMove(tile);
        i++;
        updateProgressBar();
        setTimeout(step, delay);
      }
      setTimeout(step, 120);
    }

    solveBtn.addEventListener('click', startSolver);
    window.addEventListener('keydown', (e)=>{
      if((e.key === 'b' || e.key === 'B') && !gameContainer.classList.contains('hidden')) startSolver();
      if(e.key === 'Escape' && solverRunning) stopSolverNow();
    });

    window.addEventListener('beforeunload', ()=>{ stopSolverNow(); });

    // ==================== CUSTOM POSITION PANEL ====================
    customBtn.addEventListener('click', ()=>{
      customPanel.style.display = (customPanel.style.display === 'none' || !customPanel.style.display) ? 'block' : 'none';
    });

    function parityFixIfNeeded(arr){
      // ensure solvable by swapping two non-target tiles if needed
      if(isSolvable(arr, size)) return arr;
      // swap first two tiles that are not null
      let a=-1,b=-1;
      for(let i=0;i<arr.length;i++){
        if(arr[i]!=null){
          if(a===-1) a=i; else { b=i; break; }
        }
      }
      if(a!==-1 && b!==-1){
        [arr[a],arr[b]] = [arr[b],arr[a]];
      }
      return arr;
    }

    applyCustom.addEventListener('click', ()=>{
      if(size !== 5){ alert('Custom position apply is only for 5×5 mode.'); return; }
      const tnum = Math.max(1, Math.min(24, +tileInput.value||1));
      const r = Math.max(1, Math.min(5, +rowInput.value||1))-1;
      const c = Math.max(1, Math.min(5, +colInput.value||1))-1;
      const pos = idxFromRC(r,c);
      // move that tile to pos by swapping
      const newArr = tiles.slice();
      const fromIdx = newArr.indexOf(tnum);
      if(fromIdx === -1){ alert('Tile not found.'); return; }
      [newArr[fromIdx], newArr[pos]] = [newArr[pos], newArr[fromIdx]];
      parityFixIfNeeded(newArr);

      // apply on board
      tiles = newArr;
      emptyIndex = tiles.indexOf(null);
      // re-render positions
      [...gridEl.children].forEach(tile=>{
        const num = +tile.dataset.number;
        const i = tiles.indexOf(num);
        tile.dataset.position = i;
        const {x,y} = getTranslate(i);
        tile.style.transform = `translate(${x}px,${y}px)`;
      });
      updateProgressBar();
    });

    // Help modal (about compute & efficiency)
    openHelpBtn.addEventListener('click', ()=>{
      alert(
        "Custom Position & Compute:\n\n" +
        "- আপনি Tile, Row, Column দিয়ে একটি কাস্টম স্টেট সেট করতে পারবেন।\n" +
        "- Compute চাপলে ঐ টাইলটিকে তার সঠিক goal পজিশনে আনার জন্য A* দিয়ে একটি move sequence বের করবে (অন্য টাইল এলোমেলো হতে পারে)।\n" +
        "- ফলাফল Firebase-এ সেভ হয় — পরবর্তীতে একই Tile যখন একই index পজিশনে পাওয়া যায়, cached move sequence সরাসরি ব্যবহার হবে।\n" +
        "- Tile 1 যদি bottom-right (row=5,col=5) থাকে, তাহলে movedTiles লিস্ট সহ সেভ হবে।"
      );
    });

    // ==================== COMPUTE FLOW (OVERLAY + CARD) ====================
    computeCustom.addEventListener('click', async ()=>{
      if(size !== 5){ alert('Compute is only for 5×5 mode.'); return; }
      const tnum = Math.max(1, Math.min(24, +tileInput.value||1));
      const r = Math.max(1, Math.min(5, +rowInput.value||1))-1;
      const c = Math.max(1, Math.min(5, +colInput.value||1))-1;
      const pos = idxFromRC(r,c);

      const snapshot = tiles.slice();

      // If the tile is not currently at pos, create a temporary snapshot with it at pos
      const tmp = snapshot.slice();
      const curPos = tmp.indexOf(tnum);
      if(curPos !== pos){
        [tmp[curPos], tmp[pos]] = [tmp[pos], tmp[curPos]];
        parityFixIfNeeded(tmp);
      }

      // Estimate compute time ~ distance * factor
      const goalIdx = tnum-1;
      const dr = Math.abs(Math.floor(pos/size) - Math.floor(goalIdx/size));
      const dc = Math.abs((pos%size) - (goalIdx%size));
      const estSec = Math.max(1, Math.round((dr+dc)*0.8));
      showComputeCardOverlay(tnum, pos, `~${estSec} s (heuristic)`);
      setMovesText("Computing...");

      // First: try cache
      await initFirebaseApps();
      const db = dbForTile(tnum);
      let cached = null;
      if(db){
        try{
          const key = stateKeyForTilePosition(tnum, pos);
          const snap = await db.ref(`tiles/${tnum}/${key}`).get();
          if(snap.exists()){
            cached = snap.val();
          }
        }catch(e){
          // ignore; will compute fresh
        }
      }

      if(cached && cached.moves && cached.moves.length){
        setMovesText(cached.moves.join(' '));
        cardStatus.textContent = 'Loaded from cache ✅';
        // optional: show moved tiles if present
        if(cached.movedTiles && cached.movedTiles.length){
          movedTilesRow.style.display = 'flex';
          movedTilesList.textContent = cached.movedTiles.join(', ');
        } else {
          movedTilesRow.style.display = 'none';
        }
        // Apply to board? up to user — here we won’t auto-apply
        return;
      }

      // Not cached → compute with worker (A* target)
      const w = new Worker(computeWorkerUrl);
      w.onmessage = async function(ev){
        const d = ev.data;
        if(d.type !== 'compute_result') return;
        if(d.moves && d.moves.length){
          setMovesText(d.moves.join(' '));
          // special: tile 1 in bottom-right?
          let movedTiles = d.movedTiles || [];
          if(tnum===1 && r===4 && c===4){ // 0-indexed check for row5,col5
            movedTiles = Array.from(new Set(movedTiles));
            movedTilesRow.style.display = 'flex';
            movedTilesList.textContent = movedTiles.join(', ');
          } else {
            movedTilesRow.style.display = 'none';
          }

          // Try auto-save
          let savedOk = false;
          if(db){
            try{
              const key = stateKeyForTilePosition(tnum, pos);
              const payload = {
                tile: tnum,
                posIndex: pos,
                goalIndex: goalIdx,
                moves: d.moves,
                movedTiles: movedTiles,
                explored: d.explored,
                tookMs: d.tookMs,
                savedAt: Date.now()
              };
              await db.ref(`tiles/${tnum}/${key}`).set(payload);
              savedOk = true;
            }catch(e){
              // ignore here; user can press Save to Firebase manually
            }
          }
          cardStatus.textContent = savedOk ? 'Saved ✅' : 'Not saved yet';
        } else {
          setMovesText('No moves found / timed out');
          cardStatus.textContent = 'DB check failed or not saved';
          movedTilesRow.style.display = 'none';
        }
        w.terminate();
      };
      w.postMessage({ type:'compute_tile', state: tmp, size, targetTile: tnum, goalIdx: goalIdx, nodeCap: 250000, timeCapMs: 4000 });
    });

    function showComputeCardOverlay(tile, posIdx, estText){
      estTimeEl.textContent = `Estimated compute time: ${estText}`;
      cardTileInfo.textContent = `Tile: ${tile} • Pos: ${posIdx}`;
      cardStatus.textContent = 'Not saved yet';
      overlayDim.style.display = 'block';
      computeCard.style.display = 'block';
      document.getElementById('blurScope').classList.add('blurred');
    }
    function hideComputeCardOverlay(){
      overlayDim.style.display = 'none';
      computeCard.style.display = 'none';
      document.getElementById('blurScope').classList.remove('blurred');
    }
    function setMovesText(txt){
      movesPre.textContent = txt;
    }
    closeCardBtn.addEventListener('click', hideComputeCardOverlay);

    saveToDbBtn.addEventListener('click', async ()=>{
      // Re-read info from card
      const info = cardTileInfo.textContent; // "Tile: X • Pos: Y"
      const m = info.match(/Tile:\s*(\d+)\s*•\s*Pos:\s*(\d+)/);
      if(!m){ hideComputeCardOverlay(); return; }
      const tnum = +m[1], posIdx = +m[2];
      const movesStr = movesPre.textContent.trim();
      if(!movesStr || movesStr==='Computing...' || movesStr==='No moves found / timed out'){ cardStatus.textContent = 'Nothing to save'; return; }
      const moves = movesStr.split(/\s+/);

      const goalIdx = tnum-1;
      const db = dbForTile(tnum);
      if(!db){ cardStatus.textContent = 'Firebase config missing'; return; }
      try{
        const key = stateKeyForTilePosition(tnum, posIdx);
        let movedTiles = [];
        if(document.getElementById('movedTilesRow').style.display !== 'none'){
          movedTiles = (document.getElementById('movedTilesList').textContent||'').split(/\s*,\s*/).filter(Boolean);
        }
        await db.ref(`tiles/${tnum}/${key}`).set({
          tile: tnum,
          posIndex: posIdx,
          goalIndex: goalIdx,
          moves,
          movedTiles,
          manualSaveAt: Date.now()
        });
        cardStatus.textContent = 'Saved ✅';
      }catch(e){
        cardStatus.textContent = 'Save failed: '+ (e && e.message ? e.message : 'unknown');
      }
    });

    // ==================== 5×5 SERIAL SOLVER WITH CACHE ====================
    async function solve5x5SerialWithCache(snapshot){
      // Place 1..24 serially; for each tile, if cache exists for its current position → apply;
      // otherwise compute-and-save (may shuffle others).
      for(let tileNo=1; tileNo<=24; tileNo++){
        const goalIdx = tileNo-1;
        const curIdx = tiles.indexOf(tileNo);
        if(curIdx === goalIdx) continue;

        // Try cache
        await initFirebaseApps();
        const db = dbForTile(tileNo);
        let cachedMoves = null;
        if(db){
          try{
            const key = stateKeyForTilePosition(tileNo, curIdx);
            const snap = await db.ref(`tiles/${tileNo}/${key}`).get();
            if(snap.exists()) cachedMoves = (snap.val() && snap.val().moves) || null;
          }catch(e){}
        }

        if(cachedMoves && cachedMoves.length){
          applyMovesSequence(cachedMoves, 200);
          // Wait till animation finishes
          await waitMs(cachedMoves.length*210+120);
          continue;
        }

        // No cache → compute now with worker
        const tmp = tiles.slice();
        const w = new Worker(computeWorkerUrl);
        const moves = await new Promise((resolve)=>{
          const to = setTimeout(()=>{ try{w.terminate();}catch(e){} resolve(null); }, 4500);
          w.onmessage = (ev)=>{
            const d = ev.data;
            if(d.type==='compute_result'){
              clearTimeout(to);
              try{ w.terminate(); }catch(e){}
              resolve(d.moves || null);
            }
          };
          w.postMessage({ type:'compute_tile', state: tmp, size, targetTile: tileNo, goalIdx: goalIdx, nodeCap: 250000, timeCapMs: 4000 });
        });

        if(moves && moves.length){
          applyMovesSequence(moves, 200);
          await waitMs(moves.length*210+120);
          // Save cache for this position
          if(db){
            try{
              const saveKey = stateKeyForTilePosition(tileNo, curIdx);
              await db.ref(`tiles/${tileNo}/${saveKey}`).set({
                tile: tileNo, posIndex: curIdx, goalIndex, moves, savedAt: Date.now()
              });
            }catch(e){}
          }
        } else {
          // couldn't compute — skip gracefully
        }
      }
    }

    function waitMs(ms){ return new Promise(r=>setTimeout(r, ms)); }

    // ==================== Typing effect under stages (unchanged content) ====================
    (function(){
      const subTextEl = document.getElementById('thinking-subtext');
      const messages = [
        'Analyzing with Python simulation...',
        'Evaluating heuristics...',
        'Running Minimax algorithm...',
        'Performing Monte-Carlo simulations...',
        'Checking board states...',
        'Detecting chains and loops...',
        'Applying corner and edge heuristics...',
        'Assessing sacrifice moves...',
        'Generating probabilistic outcomes...',
        'Optimizing move selection...',
        'Calculating risk factors...',
        'Scanning for traps...',
        'Validating opponent\'s options...',
        'Updating strategy matrix...',
        'Preparing final move...',
        'Almost done...',
        'Move ready to execute!',
        'বট কাজ করছে... একটু অপেক্ষা করুন!',
        'Solver বুদ্ধি খাটাচ্ছে...',
        'পাজেল বিশ্লেষণ হচ্ছে...'
      ];
      let idx = 0;
      function typeEffect(text, element, delay=30) {
        return new Promise((resolve) => {
          element.textContent = '';
          let i = 0;
          function typeChar() {
            if(i < text.length) {
              element.textContent += text.charAt(i);
              i++;
              setTimeout(typeChar, delay);
            } else { setTimeout(resolve, 900); }
          }
          typeChar();
        });
      }
      async function loopMessages() {
        while(true) {
          await typeEffect(messages[idx], subTextEl);
          idx = (idx + 1) % messages.length;
        }
      }
      loopMessages();
    })();
  </script>
</body>
</html>
