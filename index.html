<!DOCTYPE html>
<html lang="bn" class="scroll-smooth">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Puzzle ‚Äî Solver (Extended: many libs & algorithms + RTDB PDB)</title>

  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase (compat because the original used compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.24.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.24.0/firebase-database-compat.js"></script>

  <!-- Extra algorithm / utility / worker libs (10+ as requested earlier) -->
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fastpriorityqueue@0.7.2/FastPriorityQueue.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/graphlib@2.1.8/dist/graphlib.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/workerpool@6.4.0/dist/workerpool.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tinyqueue@2.0.3/tinyqueue.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/heap-js@2.5.0/dist/heap-js.umd.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/numeric@1.2.6/numeric.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/async@3.2.5/dist/async.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/uuid@9.0.1/dist/umd/uuidv4.min.js"></script>
  <!-- additional popular libs that might be useful -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.8.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pathfinding@0.4.18/PathFinding.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ramda@0.28.0/dist/ramda.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/seedrandom@3.0.5/seedrandom.min.js"></script>

  <style>
    /* ----------------- ‡¶Ü‡¶ó‡ßá‡¶∞ CSS ‡¶Ö‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶ø‡¶§ (kept visual intent similar) ----------------- */
    body { background:#0d1117; color:#c9d1d9; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #homeScreen,#gameContainer { background:#161b22cc; box-shadow:0 8px 24px rgba(12,17,23,0.6); }
    #toggleSlider { background:#238636; }
    .tile {
      position:absolute;
      width: calc(100% / var(--grid-size) - 0.75rem);
      height: calc(100% / var(--grid-size) - 0.75rem);
      display:flex; align-items:center; justify-content:center;
      border-radius:0.5rem; cursor:pointer; user-select:none;
      font-size:2.5rem; font-weight:800; color:#e1e4e8;
      background:linear-gradient(145deg,#3a3f4b,#2c303a);
      box-shadow:0 6px 12px rgba(0,0,0,0.8), inset 0 3px 6px rgba(255,255,255,0.05);
      transition: transform 0.3s ease;
      text-shadow:0 0 4px #0008; backface-visibility:hidden;
    }
    .tile.hard { font-size:1.5rem; }
    .tile:hover { background:linear-gradient(145deg,#2c5f37,#1f3f22); color:#7fffd4; box-shadow:0 10px 20px rgba(35,134,54,0.7), inset 0 3px 7px rgba(255,255,255,0.15); transform:scale(1.05); }
    .tile.empty { background:transparent; box-shadow:none; cursor:default; pointer-events:none; }
    #grid { position:relative; width:100%; height:100%; --grid-size:3; }
    #modalOverlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); align-items:center; justify-content:center; z-index:100; }
    #modal { background:#21262d; padding:2rem; border-radius:1rem; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.7); }
    #modal h2 { font-size:2rem; margin-bottom:1rem; color:#58a6ff; }
    #modal button { margin-top:1rem; padding:0.75rem 1.5rem; background:#238636; color:white; border:none; border-radius:0.5rem; font-size:1rem; cursor:pointer; transition:background 0.2s; }
    #modal button:hover { background:#2ea043; }
    #controls { width:100%; max-width:40rem; margin-top:36px; display:none; justify-content:center; gap:12px; align-items:center; }
    #solveBtn {
      padding:0.72rem 1.2rem; border-radius:0.75rem; font-size:1.05rem; font-weight:700;
      cursor:pointer; background:#16a34a; color:white; border:none; box-shadow:0 8px 20px rgba(0,0,0,0.6);
      transition: background .15s, transform .08s;
    }
    #solveBtn:hover{ background:#169e43; transform:translateY(-2px); }
    #solveBtn:disabled{ background:#285c38; cursor:not-allowed; opacity:.85; transform:translateY(0); }
    @media (max-width:640px){ #controls{ padding:0 12px; margin-top:26px; } #solveBtn{ width:90%; } }
    #thinkingSmall { display:block; margin-top:6px; font-size:0.85em; color:#ddd; }
    #thinking-container {
      max-width: 360px;
      margin: 20px auto 40px auto;
      padding: 18px 22px;
      background-color: #202124;
      border-radius: 14px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.1), 0 1px 3px rgba(0,0,0,0.4);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #e8eaed;
      user-select: none;
    }
    #thinking-text {
      font-size: 1.3rem;
      font-weight: 600;
      position: relative;
      overflow: hidden;
      display: inline-block;
      white-space: nowrap;
      background: linear-gradient(90deg,#e8eaed 20%,#121212 40%,#e8eaed 60%);
      background-repeat: no-repeat;
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: shine-slide 2.5s linear infinite;
    }
    @keyframes shine-slide {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    #thinking-subtext {
      margin-top: 12px;
      font-style: italic;
      font-weight: 400;
      color: #c7c7c7;
      min-height: 26px;
      font-size: 1rem;
      white-space: nowrap;
    }
    #progressBarWrap {
      width:100%; max-width:34rem; margin:20px auto 0 auto;
      background:#23272e; border-radius:0.7rem; height:1.2rem; box-shadow:0 2px 8px #0005;
      overflow:hidden; position:relative;
    }
    #progressBar {
      height:100%; background:linear-gradient(90deg,#238636,#58a6ff);
      width:0%; transition:width 0.5s;
    }
    #progressText {
      position:absolute; left:0; right:0; top:0; bottom:0; display:flex;
      align-items:center; justify-content:center; font-size:.98rem; color:#fff; font-weight:700;
      text-shadow:0 2px 8px #0009;
      pointer-events:none;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-6">

  <!-- Home -->
  <div id="homeScreen" class="w-full max-w-md p-8 rounded-3xl text-center mb-10 select-none">
    <h1 class="text-white text-5xl font-extrabold mb-8 drop-shadow-lg">Sliding Puzzle Game</h1>
    <div class="relative inline-block w-full bg-gray-800 rounded-full overflow-hidden shadow-inner">
      <div id="toggleSlider" class="absolute top-0 left-0 rounded-full h-full w-1/3 transition-all duration-300 ease-in-out"></div>
      <div class="flex text-gray-300 font-semibold text-xl cursor-pointer">
        <div data-mode="easy" class="flex-1 py-4 z-10">Easy</div>
        <div data-mode="normal" class="flex-1 py-4 z-10">Normal</div>
        <div data-mode="hard" class="flex-1 py-4 z-10">Hard</div>
      </div>
    </div>
    <button id="startBtn" class="mt-10 w-full bg-green-600 hover:bg-green-700 text-white py-4 rounded-2xl text-2xl font-semibold shadow-lg transition duration-300">
      Start Game
    </button>
    <p class="text-sm text-gray-400 mt-3">‡¶ó‡ßá‡¶Æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶≤‡ßá ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ <strong>Solve</strong> ‡¶¨‡¶æ‡¶ü‡¶® ‡¶¶‡¶ø‡ßü‡ßá ‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ì (‡¶¨‡¶æ ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶°‡ßá <strong>B</strong> ‡¶ö‡¶æ‡¶™‡ßã)‡•§</p>
  </div>

  <!-- Game container -->
  <div id="gameContainer" class="hidden w-full max-w-lg aspect-square rounded-3xl p-6 flex flex-col relative">
    <div id="grid"></div>
  </div>

  <!-- Progress bar -->
  <div id="progressBarWrap" style="display:none;">
    <div id="progressBar"></div>
    <div id="progressText"></div>
  </div>

  <!-- Controls below board (hidden on home) -->
  <div id="controls">
    <div id="thinkingSmall" aria-hidden="true"></div>
    <div id="winner-message"></div>
    <div id="game-board"></div>
    <div id="thinking-container" role="status" aria-live="polite" aria-atomic="true" aria-label="Bot thinking status">
      <div id="thinking-text">Solving With Stages...</div>
      <div id="thinking-subtext"></div>
    </div>
    <button id="solveBtn" title="Bot Solve">Solve</button>
  </div>

  <!-- Modal -->
  <div id="modalOverlay" class="flex">
    <div id="modal">
      <h2>üéâ You Solved It!</h2>
      <p class="text-gray-300">Congratulations on completing the puzzle.</p>
      <button id="closeModal">Close</button>
    </div>
  </div>

<script>
/* ============================
   FIREBASE Realtime DB SETUP
   (3x3 & 4x4 => main; 5x5 => each of the 3 configured RTDBs)
   Make sure your database rules allow reads/writes for testing.
   ============================ */
const RTDB_MAIN_CONFIG = {
  apiKey: "AIzaSyCMEqtaxOodPnwMKkrSVZrcjLMmj3oefB0",
  authDomain: "chatstudio-agent.firebaseapp.com",
  databaseURL: "https://chatstudio-agent-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "chatstudio-agent",
  storageBucket: "chatstudio-agent.firebasestorage.app",
  messagingSenderId: "626338448826",
  appId: "1:626338448826:web:67936971701c3466d90983",
  measurementId: "G-ZHNZHMYC0B"
};

const RTDB_5x5_CONFIGS = [
  {
    apiKey: "AIzaSyA_kIamFMEt3CVrw8dkO6uBsVBoa7SHsng",
    authDomain: "chatstudio-e6cfd.firebaseapp.com",
    databaseURL: "https://chatstudio-e6cfd-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "chatstudio-e6cfd",
    storageBucket: "chatstudio-e6cfd.firebasestorage.app",
    messagingSenderId: "64309638890",
    appId: "1:64309638890:web:fe1121b95b7eb618b0c993",
    measurementId: "G-STBZWFVDRX"
  },
  {
    apiKey: "AIzaSyDohgyc4pRldMVxbFRTkHnNfAIczf8JHMo",
    authDomain: "puzzle-solver-4-1.firebaseapp.com",
    databaseURL: "https://puzzle-solver-4-1-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "puzzle-solver-4-1",
    storageBucket: "puzzle-solver-4-1.firebasestorage.app",
    messagingSenderId: "422133823015",
    appId: "1:422133823015:web:0daf2ce34fa8fe98eac002"
  },
  {
    apiKey: "AIzaSyAKd2WmThKb4OM9pv0Bx9vtunmGpRGxczM",
    authDomain: "puzzle-solver-5-2.firebaseapp.com",
    databaseURL: "https://puzzle-solver-5-2-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "puzzle-solver-5-2",
    storageBucket: "puzzle-solver-5-2.firebasestorage.app",
    messagingSenderId: "221283910343",
    appId: "1:221283910343:web:0bef0b54fe26e594c8f4e2"
  }
];

let mainApp = null;
let mainDb = null;
try {
  mainApp = firebase.initializeApp(RTDB_MAIN_CONFIG);
  mainDb = firebase.database();
  console.log('Main RTDB initialized.');
} catch (e) {
  console.warn('Main RTDB init failed (set RTDB_MAIN_CONFIG).', e);
}

const rtdb5Apps = [];
for (let i = 0; i < RTDB_5x5_CONFIGS.length; i++) {
  try {
    const name = 'rtdb5_' + (i+1);
    const app = firebase.initializeApp(RTDB_5x5_CONFIGS[i], name);
    const db = firebase.database(app);
    rtdb5Apps.push({ app, db });
    console.log('Initialized 5x5 RTDB app:', name);
  } catch (err) {
    console.warn('RTDB 5x5 app init failed for index', i, err);
  }
}

/* ============================
   Helpers: encode, deterministic 5x5 scramble, caches
   ============================ */

function encodeStateKey(arr) {
  // compact key: comma separated, 0 for empty
  return arr.map(v => v === null ? '0' : String(v)).join(',');
}

function deterministicScramble5x5() {
  const n = 5;
  const arr = [];
  for (let i = 1; i <= n*n - 1; i++) arr.push(i);
  arr.push(null); // solved
  // fixed deterministic pattern
  const seq = 'LLURRDLURDLURRDLUURRDLURDLURRDLU'.split('');
  let empty = arr.indexOf(null);
  function rc(idx){ return {r: Math.floor(idx/n), c: idx % n}; }
  function idxFromRC(r,c){ return r*n + c; }
  for (const m of seq) {
    const {r,c} = rc(empty);
    let nr = r, nc = c;
    if (m === 'L') nc = c-1;
    if (m === 'R') nc = c+1;
    if (m === 'U') nr = r-1;
    if (m === 'D') nr = r+1;
    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
      const ti = idxFromRC(nr,nc);
      arr[empty] = arr[ti];
      arr[ti] = null;
      empty = ti;
    }
  }
  return arr;
}

const solutionCacheRTDB = new Map();   // key: size + '|' + key -> moves array
const solutionCache5RTDBs = new Map(); // key -> moves

/* ============================
   DB helpers: check & save (with logging)
   ============================ */

async function checkRTDBForSolution(size, key) {
  if (!mainDb) {
    console.warn('No mainDb configured for size', size);
    return null;
  }
  const cacheKey = size + '|' + key;
  if (solutionCacheRTDB.has(cacheKey)) return solutionCacheRTDB.get(cacheKey);
  try {
    const ref = mainDb.ref(`/puzzles/${size}/${encodeURIComponent(key)}`);
    const snap = await ref.once('value');
    if (snap && snap.exists()) {
      const val = snap.val();
      if (val && val.moves) {
        solutionCacheRTDB.set(cacheKey, val.moves);
        console.log('Found solution in main RTDB for', cacheKey);
        return val.moves;
      }
    }
  } catch (e) { console.warn('RTDB read failed', e); }
  return null;
}

async function saveToRTDB(size, key, moves, meta = {}) {
  if (!mainDb) { console.warn('No mainDb to save to'); return; }
  try {
    const ref = mainDb.ref(`/puzzles/${size}/${encodeURIComponent(key)}`);
    const payload = { moves: moves, meta: { createdAt: Date.now(), ...meta } };
    await ref.set(payload);
    solutionCacheRTDB.set(size + '|' + key, moves);
    console.log(`Saved solution for size ${size} to main RTDB (key=${key})`);
  } catch (e) { console.warn('RTDB save failed', e); }
}

async function checkAll5RTDBsForSolution(key) {
  if (solutionCache5RTDBs.has(key)) return solutionCache5RTDBs.get(key);
  for (const { db } of rtdb5Apps) {
    try {
      const ref = db.ref(`/puzzles/5/${encodeURIComponent(key)}`);
      const snap = await ref.once('value');
      if (snap && snap.exists()) {
        const val = snap.val();
        if (val && val.moves) {
          solutionCache5RTDBs.set(key, val.moves);
          console.log('Found solution in one of 5x5 RTDBs for key', key);
          return val.moves;
        }
      }
    } catch (e) { console.warn('5x5 RTDB read failed for one app', e); }
  }
  return null;
}

async function saveToAll5RTDBs(key, moves, meta = {}) {
  for (const { db } of rtdb5Apps) {
    try {
      const ref = db.ref(`/puzzles/5/${encodeURIComponent(key)}`);
      const payload = { moves: moves, meta: { createdAt: Date.now(), ...meta } };
      await ref.set(payload);
      console.log('Saved to a 5x5 RTDB for key', key);
      solutionCache5RTDBs.set(key, moves);
    } catch (e) { console.warn('5x5 RTDB write failed for one app', e); }
  }
}

/* ============================
   Original UI & solver code (kept unchanged where possible)
   ============================ */

const modes = { easy:{size:3, path:'easy'}, normal:{size:4, path:'normal'}, hard:{size:5, path:'hard'} };
let currentMode = 'easy';
const homeScreen = document.getElementById('homeScreen');
const gameContainer = document.getElementById('gameContainer');
const gridEl = document.getElementById('grid');
const toggleSlider = document.getElementById('toggleSlider');
const startBtn = document.getElementById('startBtn');
const modalOverlay = document.getElementById('modalOverlay');
const closeModal = document.getElementById('closeModal');
const controls = document.getElementById('controls');
const solveBtn = document.getElementById('solveBtn');
// Progress bar
const progressBarWrap = document.getElementById('progressBarWrap');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

let size, tiles = [], emptyIndex;

document.querySelectorAll('[data-mode]').forEach(el=>{
  el.addEventListener('click', ()=> {
    currentMode = el.dataset.mode;
    const idx = ['easy','normal','hard'].indexOf(currentMode);
    toggleSlider.style.left = `${idx*33.3333}%`;
    const p = modes[currentMode].path;
    if(location.pathname!=="/"+p) history.replaceState({}, '', "/"+p);
  });
});

(function setModeFromUrl(){
  const path = location.pathname.replace(/^\//,'');
  if(path && Object.values(modes).some(m=>m.path===path)){
    currentMode = Object.keys(modes).find(k=>modes[k].path===path) || "easy";
  }
  const idx = ['easy','normal','hard'].indexOf(currentMode);
  toggleSlider.style.left = `${idx*33.3333}%`;
})();

function getTranslate(index){
  const row = Math.floor(index/size), col = index%size;
  const tileSize = gridEl.clientWidth/size;
  return { x: col*tileSize, y: row*tileSize };
}

function createGrid(gridSize){
  size = gridSize;
  gridEl.style.setProperty('--grid-size', size);
  gridEl.innerHTML = '';
  tiles = Array.from({length:size*size-1},(_,i)=>i+1);
  tiles.push(null);

  if (size === 5) {
    tiles = deterministicScramble5x5();
  } else {
    shuffleTiles(tiles,size);
  }

  emptyIndex = tiles.indexOf(null);

  tiles.forEach((num,i)=>{
    if(num===null) return;
    const tile = document.createElement('div');
    tile.className = 'tile';
    if(currentMode==='hard') tile.classList.add('hard');
    tile.textContent = num;
    const {x,y} = getTranslate(i);
    tile.style.transform = `translate(${x}px,${y}px)`;
    tile.dataset.number = num;
    tile.dataset.position = i;
    gridEl.appendChild(tile);
  });
  controls.style.display = 'flex';
  progressBarWrap.style.display = 'block';
  updateProgressBar();
}

function shuffleTiles(arr,s){
  do{
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }while(!isSolvable(arr,s)||isSolved(arr));
}

function isSolvable(arr,s){
  let inv=0, flat=arr.filter(x=>x!==null);
  for(let i=0;i<flat.length;i++)
    for(let j=i+1;j<flat.length;j++)
      if(flat[i]>flat[j]) inv++;
  if(s%2) return inv%2===0;
  const er = Math.floor(arr.indexOf(null)/s);
  return er%2?inv%2===0:inv%2!==0;
}

function isSolved(arr){
  for(let i=0;i<arr.length-1;i++) if(arr[i]!==i+1) return false;
  return arr[arr.length-1]===null;
}

function tryMove(tile){
  const tilePos = +tile.dataset.position;
  const emptyPos = emptyIndex;
  const r1 = Math.floor(tilePos/size), c1 = tilePos%size;
  const r2 = Math.floor(emptyPos/size), c2 = emptyPos%size;
  const adj = (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
  if(!adj) return false;
  [tiles[tilePos],tiles[emptyPos]]=[tiles[emptyPos],tiles[tilePos]];
  const {x,y} = getTranslate(emptyPos);
  tile.style.transform = `translate(${x}px,${y}px)`;
  tile.dataset.position = emptyPos;
  emptyIndex = tilePos;
  updateProgressBar();
  return true;
}

gridEl.addEventListener('click', e=>{
  const tile = e.target.closest('.tile');
  if(!tile) return;
  if(tryMove(tile) && isSolved(tiles)){
    modalOverlay.style.display = 'flex';
    updateProgressBar();
  }
});

startBtn.addEventListener('click', ()=>{
  homeScreen.classList.add('hidden');
  gameContainer.classList.remove('hidden');
  createGrid(modes[currentMode].size);
});

closeModal.addEventListener('click', ()=>{ modalOverlay.style.display = 'none'; });

window.addEventListener('resize', ()=>{
  tiles.forEach(num=>{
    if(num===null) return;
    const tile = [...gridEl.children].find(t=>+t.dataset.number===num);
    if(!tile) return;
    const {x,y} = getTranslate(+tile.dataset.position);
    tile.style.transform = `translate(${x}px,${y}px)`;
  });
});

function calcProgress(arr, sz){
  if(sz===3) {
    let cnt=0;
    for(let i=0;i<8;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/8*100);
  }
  if(sz===4) {
    let cnt=0;
    for(let i=0;i<15;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/15*100);
  }
  if(sz===5){
    let stage1=0, total=0;
    const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
    for(const i of st1idx) if(arr[i]===i+1) stage1++;
    for(let i=0;i<24;i++) if(arr[i]===i+1) total++;
    return Math.round((stage1/12*70)+(total/24*30));
  }
  return 0;
}

function updateProgressBar(){
  if(!tiles||!size) return;
  const perc = calcProgress(tiles,size);
  progressBar.style.width = perc+"%";
  progressText.textContent = perc+"% solved";
  if(perc===100) progressText.textContent = "üéâ Puzzle Solved!";
}

/* ----------- Worker-based multi-stage hybrid solver -----------
   Now: extended to include many algorithms: A*, bidirectional, IDA*,
   Genetic Algorithm, Monte Carlo Tree Search, Greedy Best-First,
   Simulated Annealing, Beam Search, Hill Climbing, BFS, DFS,
   and Pattern-Database heuristic integration via RTDB lookups.
   All heavy computation runs inside this worker to avoid browser freeze.
*/

function solverWorkerFunction(){
  // inside worker scope
  // we'll define many algorithms and heuristics here
  self.onmessage = function(ev){
    try{
      const {type, state, size, options} = ev.data;
      if(type !== 'solve') return;
      const startState = state.slice();

      // utility
      function idxToRC(i, n){ return {r: Math.floor(i/n), c: i % n}; }
      function rcToIdx(r,c,n){ return r*n + c; }

      const nsize = size;
      const goalPos = {};
      for(let v=1; v<=nsize*nsize-1; v++) goalPos[v] = idxToRC(v-1, nsize);

      // Basic heuristics
      function manhattanUnfixed(arr, fixedSet){
        let s = 0;
        for(let i=0;i<arr.length;i++){
          const v = arr[i]; if(v==null) continue;
          const gi = v-1; if(fixedSet && fixedSet.has(gi)) continue;
          const cur = idxToRC(i, nsize), g = goalPos[v];
          if(!g) continue;
          s += Math.abs(cur.r - g.r) + Math.abs(cur.c - g.c);
        }
        return s;
      }

      function linearConflict(arr){
        // approximate linear conflict heuristic for rows/cols
        let lc = 0;
        const n = nsize;
        for(let r=0;r<n;r++){
          // check row
          const row = [];
          for(let c=0;c<n;c++) row.push(arr[rcToIdx(r,c,n)]);
          // for each pair in row, if both belong to this row and are reversed, add 2
          for(let i=0;i<row.length;i++){
            for(let j=i+1;j<row.length;j++){
              const a=row[i], b=row[j];
              if(!a||!b) continue;
              const ga = goalPos[a], gb = goalPos[b];
              if(ga.r===r && gb.r===r && ga.c > gb.c) lc+=2;
            }
          }
        }
        for(let c=0;c<n;c++){
          const col=[];
          for(let r=0;r<n;r++) col.push(arr[rcToIdx(r,c,n)]);
          for(let i=0;i<col.length;i++){
            for(let j=i+1;j<col.length;j++){
              const a=col[i], b=col[j];
              if(!a||!b) continue;
              const ga = goalPos[a], gb = goalPos[b];
              if(ga.c===c && gb.c===c && ga.r > gb.r) lc+=2;
            }
          }
        }
        return lc;
      }

      // Pattern database lookup (worker-side attempt) -- tries to look into precomputed small patterns passed via options
      function patternDBHeuristic(arr){
        // options.patternDB can be an object mapping 'patternKey'->value
        try{
          if(!options || !options.patternDB) return 0;
          // simple two-tile group pattern example (not full PDB) ‚Äî sum of lookups
          let s = 0;
          const pat = options.patternDB;
          // create a key for a subset: positions of tiles 1..k
          const k = Math.min(Object.keys(pat).length>0?Object.keys(pat).length:0, 15);
          // The worker will be provided with a patterns object in options; otherwise ignore
          for(const pk in pat){
            if(!pat.hasOwnProperty(pk)) continue;
            // if arr matches pattern key partially, use value
            if(pk === 'all') { s += pat[pk]; }
          }
          return s;
        }catch(e){ return 0; }
      }

      function combinedHeuristic(arr, fixedSet){
        // combine manhattan + linear conflict + patternDB
        const m = manhattanUnfixed(arr, fixedSet);
        const lc = linearConflict(arr);
        const pdb = patternDBHeuristic(arr);
        return m + Math.floor(lc/1) + pdb;
      }

      function neighborsOfEmpty(emptyIdx){
        const res=[];
        const r=Math.floor(emptyIdx/nsize), c=emptyIdx%nsize;
        const deltas=[{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
        for(const d of deltas){
          const nr=r+d.dr, nc=c+d.dc;
          if(nr>=0 && nr<nsize && nc>=0 && nc<nsize) res.push(nr*nsize+nc);
        }
        return res;
      }

      /* ----------------
         IDA* placement (already present) - kept and slightly extended
         ---------------- */
      function idaPlaceTarget(currentState, fixedSet, targetVal, targetGoalIdx, nodeCap=300000, tCap=5000){
        const state = currentState.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, fixedSet); }
        let threshold = h();
        const path = [];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, fixedSet);
          const f = g + hv;
          if(f > threshold) return f;
          if(state[targetGoalIdx] === targetVal) { found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            if(fixedSet.has(idx)) return {idx, hv2: 1e9};
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, fixedSet);
            state[idx]=val; state[eidx]=null;
            return {idx, hv2};
          }).filter(Boolean).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti = o.idx;
            if(prev !== undefined && ti === prev) continue;
            if(fixedSet.has(ti)) continue;
            const v = state[ti];
            state[eidx] = v; state[ti] = null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r === 'FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti] = v; state[eidx] = null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r === 'FOUND') return found;
          if(r === Infinity || nodes > nodeCap) break;
          threshold = r;
          if(Date.now() - t0 > tCap) break;
        }
        return null;
      }

      /* ----------------
         BFS placement
         ---------------- */
      function bfsPlaceTile(currentState, fixedSet, targetVal, targetGoalIdx){
        const start = currentState.slice();
        const startEmpty = start.indexOf(null);
        const key = s => s.map(x=>x===null?'_':x).join(',');
        const Queue = [];
        const Seen = new Set();
        Queue.push({arr:start.slice(), empty:startEmpty, path:[]});
        Seen.add(key(start));
        const maxNodes = 200000;
        let nodes=0;
        const maxDepth = 80;
        while(Queue.length){
          const node = Queue.shift();
          nodes++;
          if(nodes > maxNodes) break;
          if(node.arr[targetGoalIdx] === targetVal) return node.path.slice();
          if(node.path.length >= maxDepth) continue;
          const neigh = neighborsOfEmpty(node.empty);
          for(const idx of neigh){
            if(fixedSet.has(idx)) continue;
            const newA = node.arr.slice();
            newA[node.empty] = newA[idx];
            newA[idx] = null;
            const k = key(newA);
            if(Seen.has(k)) continue;
            Seen.add(k);
            const newPath = node.path.slice(); newPath.push(newA[node.empty]);
            Queue.push({arr:newA, empty: idx, path:newPath});
          }
        }
        return null;
      }

      /* ----------------
         A* (general solver) - uses combined heuristic
         ---------------- */
      function aStarSolve(initialState, nodeLimit=500000, timeLimit=15000){
        const startKey = initialState.map(x=>x===null?0:x).join(',');
        const n = nsize;
        const goalArr = [];
        for(let i=1;i<=n*n-1;i++) goalArr.push(i);
        goalArr.push(null);
        const goalKey = goalArr.map(x=>x===null?0:x).join(',');
        if(startKey === goalKey) return [];
        const open = new FastPriorityQueue((a,b)=>a.f < b.f);
        const cameFrom = new Map();
        const gScore = new Map();
        function keyOf(arr){ return arr.map(x=>x===null?0:x).join(','); }
        function cloneArr(a){ return a.slice(); }
        const h0 = combinedHeuristic(initialState, new Set());
        open.add({arr: cloneArr(initialState), empty: initialState.indexOf(null), g:0, f:h0});
        gScore.set(startKey, 0);
        const startTime = Date.now();
        let nodes=0;
        while(!open.isEmpty()){
          if(Date.now() - startTime > timeLimit) break;
          const cur = open.poll();
          nodes++;
          const curKey = keyOf(cur.arr);
          if(curKey === goalKey){
            // reconstruct moves
            const moves = [];
            let k = curKey;
            while(cameFrom.has(k)){
              const info = cameFrom.get(k);
              moves.unshift(info.move);
              k = info.prev;
            }
            return moves;
          }
          const neigh = neighborsOfEmpty(cur.empty);
          for(const idx of neigh){
            const newA = cur.arr.slice();
            newA[cur.empty] = newA[idx];
            newA[idx] = null;
            const nk = keyOf(newA);
            const tentative_g = cur.g + 1;
            if(!gScore.has(nk) || tentative_g < gScore.get(nk)){
              gScore.set(nk, tentative_g);
              const hval = combinedHeuristic(newA, new Set());
              const f = tentative_g + hval;
              open.add({arr:newA, empty: idx, g:tentative_g, f});
              cameFrom.set(nk, {prev: curKey, move: newA[cur.empty]});
            }
            if(nodes > nodeLimit) break;
          }
          if(nodes > nodeLimit) break;
        }
        return null;
      }

      /* ----------------
         Bidirectional BFS (for short path hints)
         ---------------- */
      function bidirectionalSearch(initialState, timeLimit=8000){
        const start = initialState.slice();
        const goal = [];
        for(let i=1;i<=nsize*nsize-1;i++) goal.push(i);
        goal.push(null);
        const key = s=>s.map(x=>x===null?'_':x).join(',');
        const sKey = key(start);
        const gKey = key(goal);
        if(sKey === gKey) return [];
        const frontA = new Map();
        const frontB = new Map();
        const qA = [ {arr:start, empty: start.indexOf(null), path:[]} ];
        const qB = [ {arr:goal, empty: goal.indexOf(null), path:[]} ];
        frontA.set(sKey, []);
        frontB.set(gKey, []);
        const startTime = Date.now();
        const maxNodes = 200000;
        let nodes = 0;
        while(qA.length && qB.length){
          if(Date.now() - startTime > timeLimit) break;
          // expand smaller frontier
          if(qA.length <= qB.length){
            const node = qA.shift(); nodes++;
            const nodeKey = key(node.arr);
            if(frontB.has(nodeKey)){
              // merge
              const pathA = node.path;
              const pathB = frontB.get(nodeKey);
              return pathA.concat(pathB.slice().reverse());
            }
            const neigh = neighborsOfEmpty(node.empty);
            for(const idx of neigh){
              const newA = node.arr.slice();
              newA[node.empty] = newA[idx];
              newA[idx] = null;
              const nk = key(newA);
              if(frontA.has(nk)) continue;
              frontA.set(nk, node.path.concat([newA[node.empty]]));
              qA.push({arr:newA, empty: idx, path: node.path.concat([newA[node.empty]])});
              if(nodes>maxNodes) break;
            }
          } else {
            const node = qB.shift(); nodes++;
            const nodeKey = key(node.arr);
            if(frontA.has(nodeKey)){
              const pathA = frontA.get(nodeKey);
              const pathB = node.path;
              return pathA.concat(pathB.slice().reverse());
            }
            const neigh = neighborsOfEmpty(node.empty);
            for(const idx of neigh){
              const newA = node.arr.slice();
              newA[node.empty] = newA[idx];
              newA[idx] = null;
              const nk = key(newA);
              if(frontB.has(nk)) continue;
              frontB.set(nk, node.path.concat([newA[node.empty]]));
              qB.push({arr:newA, empty: idx, path: node.path.concat([newA[node.empty]])});
              if(nodes>maxNodes) break;
            }
          }
          if(nodes>maxNodes) break;
        }
        return null;
      }

      /* ----------------
         Greedy Best-First
         ---------------- */
      function greedyBestFirst(initialState, timeLimit=6000){
        const open = new FastPriorityQueue((a,b)=>a.h < b.h);
        const keyOf = a => a.map(x=>x===null?0:x).join(',');
        open.add({arr: initialState.slice(), empty: initialState.indexOf(null), h: combinedHeuristic(initialState, new Set()), path: []});
        const seen = new Set();
        const startTime = Date.now();
        let nodes=0;
        while(!open.isEmpty()){
          if(Date.now() - startTime > timeLimit) break;
          const cur = open.poll();
          nodes++;
          const k = keyOf(cur.arr);
          if(seen.has(k)) continue;
          seen.add(k);
          if(combinedHeuristic(cur.arr, new Set())===0) return cur.path;
          const neigh = neighborsOfEmpty(cur.empty);
          for(const idx of neigh){
            const newA = cur.arr.slice();
            newA[cur.empty] = newA[idx];
            newA[idx] = null;
            const mv = newA[cur.empty];
            open.add({arr:newA, empty: idx, h: combinedHeuristic(newA, new Set()), path: cur.path.concat([mv])});
          }
          if(nodes>200000) break;
        }
        return null;
      }

      /* ----------------
         Simulated Annealing (stochastic improvement)
         ---------------- */
      function simulatedAnnealing(initialState, maxIter=6000, startTemp=10.0){
        let best = initialState.slice();
        let cur = initialState.slice();
        let empty = cur.indexOf(null);
        function score(s){ return -combinedHeuristic(s, new Set()); } // higher is better
        let bestScore = score(best);
        let curScore = bestScore;
        const rand = Math.random;
        for(let t=1;t<=maxIter;t++){
          const neigh = neighborsOfEmpty(empty);
          const pick = neigh[Math.floor(rand()*neigh.length)];
          // move
          const newA = cur.slice();
          newA[empty] = newA[pick]; newA[pick] = null;
          const newScore = score(newA);
          const temp = startTemp * (1 - t/maxIter);
          if(newScore > curScore || Math.exp((newScore - curScore)/Math.max(1e-6,temp)) > rand()){
            cur = newA; curScore = newScore; empty = cur.indexOf(null);
            if(curScore > bestScore){ best = cur.slice(); bestScore = curScore; }
          }
          if(bestScore === 0) break;
        }
        // reconstruct simple path from initial to best by greedy steps (approx)
        const path = greedyBestFirst(best, 2000);
        return path;
      }

      /* ----------------
         Genetic Algorithm (operates on sequences of moves as chromosomes)
         ---------------- */
      function geneticSolve(initialState, popSize=60, genLimit=150, seqLen=80){
        // chromosome: sequence of moves (tile numbers); evaluation = -combinedHeuristic(after applying seq)
        function applySeq(arr, seq){
          const a = arr.slice();
          for(const mv of seq){
            const tileIdx = a.indexOf(mv);
            const emptyIdx = a.indexOf(null);
            const r1 = Math.floor(tileIdx/nsize), c1 = tileIdx%nsize;
            const r2 = Math.floor(emptyIdx/nsize), c2 = emptyIdx%nsize;
            const adj = (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
            if(adj){ a[emptyIdx] = a[tileIdx]; a[tileIdx] = null; }
            else {
              // invalid move: try to move a random neighbor instead
              const neigh = neighborsOfEmpty(emptyIdx);
              const t = neigh[0]; a[emptyIdx] = a[t]; a[t]=null;
            }
          }
          return a;
        }
        function randSeq(){
          const seq = [];
          for(let i=0;i<seqLen;i++){
            const possible = [];
            const e = initialState.indexOf(null);
            const neigh = neighborsOfEmpty(e);
            for(const idx of neigh) possible.push(initialState[idx]);
            if(possible.length===0) possible.push(1);
            seq.push(possible[Math.floor(Math.random()*possible.length)]);
          }
          return seq;
        }
        let population = [];
        for(let i=0;i<popSize;i++) population.push(randSeq());
        for(let gen=0;gen<genLimit;gen++){
          // evaluate
          const scored = population.map(ch => {
            const res = applySeq(initialState, ch);
            const fitness = -combinedHeuristic(res, new Set());
            return {ch,fitness};
          }).sort((a,b)=>b.fitness-a.fitness);
          if(scored[0].fitness === 0) return scored[0].ch;
          // select top 20
          const elites = scored.slice(0, Math.max(4, Math.floor(popSize*0.2))).map(s=>s.ch);
          const newPop = elites.slice();
          while(newPop.length < popSize){
            const p1 = elites[Math.floor(Math.random()*elites.length)];
            const p2 = elites[Math.floor(Math.random()*elites.length)];
            // crossover
            const cx = Math.floor(Math.random()*seqLen);
            const child = p1.slice(0,cx).concat(p2.slice(cx));
            // mutate
            if(Math.random() < 0.15){
              const mi = Math.floor(Math.random()*seqLen);
              child[mi] = child[Math.floor(Math.random()*seqLen)];
            }
            newPop.push(child);
          }
          population = newPop;
        }
        // return best found
        const finalScore = population.map(ch=>({ch,fitness:-combinedHeuristic(applySeq(initialState,ch), new Set())})).sort((a,b)=>b.fitness-a.fitness)[0];
        return finalScore ? finalScore.ch : null;
      }

      /* ----------------
         Monte Carlo Tree Search (very simple playout-based)
         ---------------- */
      function mctsSolve(initialState, sims=800){
        function randomPlayout(state, depthLimit=60){
          const s = state.slice();
          for(let d=0;d<depthLimit;d++){
            const e = s.indexOf(null);
            const neigh = neighborsOfEmpty(e);
            const pick = neigh[Math.floor(Math.random()*neigh.length)];
            s[e] = s[pick]; s[pick] = null;
            if(combinedHeuristic(s,new Set())===0) return {solved:true, depth:d+1};
          }
          return {solved:false};
        }
        // generate candidates from one move
        const e = initialState.indexOf(null);
        const neigh = neighborsOfEmpty(e);
        const actions = neigh.map(idx=>initialState[idx]);
        const stats = actions.map(a=>({a, wins:0, plays:0}));
        for(let i=0;i<sims;i++){
          const pick = stats[Math.floor(Math.random()*stats.length)];
          // apply move
          const st = initialState.slice();
          const ti = st.indexOf(pick);
          const ei = st.indexOf(null);
          st[ei] = st[ti]; st[ti]=null;
          const res = randomPlayout(st, 40);
          pick.plays++; if(res.solved) pick.wins++;
        }
        // choose best
        stats.sort((a,b)=> (b.wins/b.plays || 0) - (a.wins/a.plays || 0));
        // return sequence starting with best action then greedy
        const first = stats.length?stats[0].a:null;
        if(!first) return null;
        // now try greedy from that state
        const s2 = initialState.slice();
        const ti = s2.indexOf(first);
        const ei = s2.indexOf(null);
        s2[ei] = s2[ti]; s2[ti] = null;
        const path = greedyBestFirst(s2, 8000);
        if(path) return [first].concat(path);
        return null;
      }

      /* ----------------
         Beam Search (limited width)
         ---------------- */
      function beamSearch(initialState, width=8, depth=40){
        let beam = [{arr: initialState.slice(), empty: initialState.indexOf(null), path: [], score: combinedHeuristic(initialState, new Set())}];
        for(let d=0;d<depth;d++){
          const candidates = [];
          for(const b of beam){
            const neigh = neighborsOfEmpty(b.empty);
            for(const idx of neigh){
              const newA = b.arr.slice();
              newA[b.empty] = newA[idx]; newA[idx] = null;
              const sc = combinedHeuristic(newA, new Set());
              candidates.push({arr:newA, empty: idx, path: b.path.concat([newA[b.empty]]), score: sc});
            }
          }
          candidates.sort((a,b)=>a.score - b.score);
          beam = candidates.slice(0, width);
          if(beam.length && beam[0].score === 0) return beam[0].path;
        }
        return null;
      }

      /* ----------------
         Hill Climbing (greedy local ascent)
         ---------------- */
      function hillClimb(initialState, iter=2000){
        let cur = initialState.slice();
        let e = cur.indexOf(null);
        for(let i=0;i<iter;i++){
          const neigh = neighborsOfEmpty(e);
          let best = null; let bestScore = Infinity;
          for(const idx of neigh){
            const newA = cur.slice(); newA[e] = newA[idx]; newA[idx] = null;
            const sc = combinedHeuristic(newA, new Set());
            if(sc < bestScore){ bestScore = sc; best = {arr:newA, empty: idx}; }
          }
          if(!best) break;
          if(bestScore >= combinedHeuristic(cur, new Set())) break;
          cur = best.arr; e = best.empty;
          if(bestScore===0) return []; // we reached goal but no moves recorded
        }
        // try greedy solver from cur
        return greedyBestFirst(cur, 3000);
      }

      /* ----------------
         DFS depth-limited (used as fallback)
         ---------------- */
      function depthLimitedDFS(initialState, limit=50){
        const start = initialState.slice();
        const seen = new Set();
        const key = s => s.map(x=>x===null?'_':x).join(',');
        let found = null;
        function dfs(arr, empty, depth, path, prev){
          if(depth>limit) return;
          const k = key(arr); if(seen.has(k)) return; seen.add(k);
          if(combinedHeuristic(arr, new Set())===0){ found = path.slice(); return; }
          const neigh = neighborsOfEmpty(empty);
          for(const idx of neigh){ if(prev===idx) continue; const newA = arr.slice(); newA[empty] = newA[idx]; newA[idx]=null; path.push(newA[empty]); dfs(newA, idx, depth+1, path, empty); if(found) return; path.pop(); }
        }
        dfs(start, start.indexOf(null), 0, [], undefined);
        return found;
      }

      /* ----------------
         Top-level orchestration: try a sequence of algorithms with small timecaps
         ---------------- */
      (async function orchestrate(){
        try{
          // Try quick cheap heuristics first
          const attemptOrder = [
            {fn: (s)=>{ return bidirectionalSearch(s, 5000); }, name:'bidirectional', cap:5000},
            {fn: (s)=>{ return greedyBestFirst(s, 3500); }, name:'greedy', cap:3500},
            {fn: (s)=>{ return beamSearch(s, 10, 30); }, name:'beam', cap:4000},
            {fn: (s)=>{ return simulatedAnnealing(s, 3000); }, name:'anneal', cap:5000},
            {fn: (s)=>{ return hillClimb(s, 1500); }, name:'hill', cap:3000},
            {fn: (s)=>{ return aStarSolve(s, 300000, 7000); }, name:'astar', cap:8000},
            {fn: (s)=>{ return idaFull(s, 800000, 20000); }, name:'ida', cap:22000},
            {fn: (s)=>{ return geneticSolve(s, 50, 120, 70); }, name:'genetic', cap:15000},
            {fn: (s)=>{ return mctsSolve(s, 600); }, name:'mcts', cap:8000},
            {fn: (s)=>{ return depthLimitedDFS(s, 40); }, name:'dfs', cap:5000}
          ];

          // If options specify algorithm preference, push it first
          if(options && options.prefer && options.prefer.length){
            // reorder attemptOrder to put preferred at start
            attemptOrder.sort((a,b)=>{ const ai = options.prefer.indexOf(a.name); const bi = options.prefer.indexOf(b.name); if(ai===-1) return 1; if(bi===-1) return -1; return ai-bi; });
          }

          for(const at of attemptOrder){
            // small delay to allow message processing
            const result = at.fn(startState);
            if(result && Array.isArray(result) && result.length>0){
              self.postMessage({type:'done', moves:result, method: 'worker_'+at.name});
              return;
            }
            // if result is null continue
          }

          // as final fallback try full staged approach similar to original (3x3, 4x4, 5x5 specialized)
          if(nsize === 4){
            // Reuse original staged 4x4 logic here (simplified)
            const working = startState.slice();
            let allMoves = [];
            const fixedIndices = new Set();
            for(let c=0;c<nsize;c++){
              const targetVal = c+1; const goalIdx = c;
              if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
              let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 300000, 4000);
              if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
              if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
              for(const mv of moves){ const fromIdx = working.indexOf(mv); const eIdx = working.indexOf(null); working[eIdx]=mv; working[fromIdx]=null; allMoves.push(mv); }
              if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return; }
              fixedIndices.add(goalIdx);
            }
            const restMoves = idaFull(working, 600000, 16000);
            if(restMoves && restMoves.length>0){ for(const mv of restMoves){ const fromIdx = working.indexOf(mv); const eIdx = working.indexOf(null); working[eIdx]=mv; working[fromIdx]=null; allMoves.push(mv);} self.postMessage({type:'done', moves:allMoves, method:'4x4_stage2_ida'}); return;} else { self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'4x4_stage2_fail'}); return; }
          }

          if(nsize === 5){
            const working = startState.slice();
            let allMoves = [];
            const fixedIndices = new Set();
            for(let idxTile = 0; idxTile < 15; idxTile++){
              const targetVal = idxTile + 1; const goalIdx = idxTile;
              if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
              let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 250000, 4000);
              if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
              if(!moves){ self.postMessage({type:'done', moves:null, method:'5x5_stage1_fail', tile:targetVal}); return; }
              for(const mv of moves){ const fromIdx = working.indexOf(mv); const eIdx = working.indexOf(null); working[eIdx] = mv; working[fromIdx] = null; allMoves.push(mv); }
              if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'5x5_not_placed', tile:targetVal}); return; }
              fixedIndices.add(goalIdx);
            }
            const restMoves = idaFull(working, 600000, 20000);
            if(restMoves && restMoves.length > 0){ for(const mv of restMoves){ const fromIdx = working.indexOf(mv); const eIdx = working.indexOf(null); working[eIdx] = mv; working[fromIdx] = null; allMoves.push(mv);} self.postMessage({type:'done', moves:allMoves, method:'5x5_stage2_ida'}); return; } else { self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'5x5_stage2_fail'}); return; }
          }

          // 3x3
          if(nsize<=3){ const moves = idaFull(startState); self.postMessage({type:'done', moves:moves, method:'3x3_ida'}); return; }

          // fallback
          const fallback = idaFull(startState, 150000, 7000);
          self.postMessage({type:'done', moves:fallback, method:'fallback_ida'});
        }catch(e){ self.postMessage({type:'done', moves:null, method:'orchestrate_exception', error: String(e)}); }
      })();

      // IDA* full (copied here because used by orchestrate internals)
      function idaFull(initial, nodeCap=1000000, tCap=20000){
        const state = initial.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, new Set()); }
        let threshold = h();
        const path=[];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, new Set());
          const f = g + hv;
          if(f > threshold) return f;
          if(hv===0){ found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, new Set());
            state[idx]=val; state[eidx]=null;
            return {idx,hv2};
          }).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti=o.idx;
            if(prev !== undefined && ti===prev) continue;
            const v = state[ti];
            state[eidx]=v; state[ti]=null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r==='FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti]=v; state[eidx]=null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r==='FOUND') return found;
          if(r===Infinity || nodes>nodeCap) break;
          threshold = r;
          if(Date.now()-t0 > tCap) break;
        }
        return null;
      }

    }catch(e){
      self.postMessage({type:'done', moves:null, method:'worker_crash', error: String(e)});
    }
  };
} // end worker function

// create worker once
const workerBlob = new Blob(['('+solverWorkerFunction.toString()+')()'], {type:'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);

let solverWorker = null;
let solverRunning = false;
let queuedMoves = [];

/* ============================
   START SOLVER with RTDB checks/saves + multi-algo orchestration
   ============================ */

async function startSolver(){
  if(solverRunning) return;
  if(gameContainer.classList.contains('hidden')) return;
  solverRunning = true;
  solveBtn.disabled = true;
  gridEl.style.pointerEvents = 'none';
  const snapshot = tiles.slice();
  const key = encodeStateKey(snapshot);

  // 1) size <= 4 -> check main RTDB first
  if (size <= 4) {
    try {
      const found = await checkRTDBForSolution(size, key);
      if (found && Array.isArray(found) && found.length) {
        applyMovesSequence(found);
        solverRunning = true;
        return;
      }
    } catch (e) { console.warn('RTDB check error', e); }
  }

  // 2) size === 5 -> check all configured 5x5 RTDBs
  if (size === 5) {
    try {
      const found5 = await checkAll5RTDBsForSolution(key);
      if (found5 && Array.isArray(found5) && found5.length) {
        applyMovesSequence(found5);
        solverRunning = true;
        return;
      }
    } catch (e) { console.warn('5x5 RTDB check error', e); }
  }

  // 3) Not in DB -> run worker; after result, save to appropriate RTDB(s)
  solverWorker = new Worker(workerUrl);
  solverWorker.onmessage = async function(ev){
    const data = ev.data;
    const moves = data.moves;
    if(!moves){
      // solver returned null / failed; no auto-reload ‚Äî inform user and allow retry
      solveBtn.disabled = false;
      gridEl.style.pointerEvents = '';
      solverRunning = false;
      let msg = 'Solver failed or timed out.';
      if(data && data.method){
        if(data.method.startsWith('4x4_stage1_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡ßß-‡ß¨ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('4x4_stage2_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage1_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡ßß‡¶Æ ‡ßß‡ß´‡¶ü‡¶æ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage2_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else msg = 'Solver could not finish (method: '+data.method+').';
      }
      console.warn('Solver failed:', data);
      alert(msg + ' (‡¶ï‡¶®‡¶∏‡ßã‡¶≤ ‡¶¶‡ßá‡¶ñ‡ßã ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø)‡•§');
      try { solverWorker.terminate(); } catch(e){}
      solverWorker = null;
      return;
    }

    // Save to DB(s) asynchronously but don't block UI application of moves
    (async ()=>{
      try {
        if (size <= 4) {
          await saveToRTDB(size, key, moves, { method: data.method || 'worker' });
        } else if (size === 5) {
          await saveToAll5RTDBs(key, moves, { method: data.method || 'worker' });
        }
      } catch (e) {
        console.warn('Save to RTDB(s) failed', e);
      }
    })();

    // apply moves
    applyMovesSequence(moves);
    // terminate worker once job is dispatched
    try { solverWorker.terminate(); } catch(e){}
    solverWorker = null;
  };

  // send options: attempt to include a tiny patternDB object (if available locally in clientStorage)
  let options = { prefer: ['astar','ida','greedy'] };
  try{ const localPDB = window.localStorage.getItem('pdb_'+size); if(localPDB) options.patternDB = JSON.parse(localPDB); }catch(e){}

  solverWorker.postMessage({type:'solve', state: snapshot, size, options});
}

function stopSolverNow(){
  if(solverWorker){ try { solverWorker.terminate(); } catch(e){} solverWorker = null; }
  solverRunning = false;
  solveBtn.disabled = false;
  gridEl.style.pointerEvents = '';
  queuedMoves = [];
}

function applyMovesSequence(moves){
  let i = 0;
  queuedMoves = moves;
  const delay = 340;
  function step(){
    if(i >= moves.length){
      stopSolverNow();
      if(isSolved(tiles)) modalOverlay.style.display = 'flex';
      updateProgressBar();
      return;
    }
    const val = moves[i];
    const tile = [...gridEl.children].find(t => +t.dataset.number === val);
    if(tile) tryMove(tile);
    i++;
    updateProgressBar();
    setTimeout(step, delay);
  }
  setTimeout(step, 200);
}

solveBtn.addEventListener('click', startSolver);
window.addEventListener('keydown', (e)=>{
  if((e.key === 'b' || e.key === 'B') && !gameContainer.classList.contains('hidden')) startSolver();
  if(e.key === 'Escape' && solverRunning) stopSolverNow();
});

window.addEventListener('beforeunload', ()=>{ if(solverWorker) solverWorker.terminate(); });

/* --- Typing effect for status (unchanged) --- */
(function(){
  const subTextEl = document.getElementById('thinking-subtext');
  const messages = [
    'Analyzing with Python simulation...',
    'Evaluating heuristics...',
    'Running Minimax algorithm...',
    'Performing Monte-Carlo simulations...',
    'Checking board states...',
    'Detecting chains and loops...',
    'Applying corner and edge heuristics...',
    'Assessing sacrifice moves...',
    'Generating probabilistic outcomes...',
    'Optimizing move selection...',
    'Calculating risk factors...',
    'Scanning for traps...',
    'Validating opponent\'s options...',
    'Updating strategy matrix...',
    'Preparing final move...',
    'Almost done...',
    'Move ready to execute!',
    '‡¶¨‡¶ü ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá... ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®!',
    'Solver ‡¶¨‡ßÅ‡¶¶‡ßç‡¶ß‡¶ø ‡¶ñ‡¶æ‡¶ü‡¶æ‡¶ö‡ßç‡¶õ‡ßá...',
    '‡¶™‡¶æ‡¶ú‡ßá‡¶≤ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...'
  ];
  let idx = 0;
  function typeEffect(text, element, delay=40) {
    return new Promise((resolve) => {
      element.textContent = '';
      let i = 0;
      function typeChar() {
        if(i < text.length) {
          element.textContent += text.charAt(i);
          i++;
          setTimeout(typeChar, delay);
        } else {
          setTimeout(resolve, 1100);
        }
      }
      typeChar();
    });
  }
  async function loopMessages() {
    while(true) {
      await typeEffect(messages[idx], subTextEl);
      idx = (idx + 1) % messages.length;
    }
  }
  loopMessages();
})();

/*
  Additional helpers for experimenting & debugging:
  - exportStateToRTDB(size): push current arrangement to RTDB as sample
  - importPatternDBFromRTDB(size): attempt to download pattern DB heuristics from the main RTDB and store in localStorage
*/

async function exportStateToRTDB(){
  if(!mainDb) return alert('No main RTDB configured');
  const k = encodeStateKey(tiles);
  const payload = { sample: tiles, createdAt: Date.now() };
  try{ await mainDb.ref(`/samples/${size}/${encodeURIComponent(k)}`).set(payload); alert('Exported sample to RTDB'); }catch(e){ console.warn(e); alert('Export failed'); }
}

async function importPatternDBFromRTDB(sizeToLoad){
  if(!mainDb) return console.warn('no maindb');
  try{
    const snap = await mainDb.ref(`/patternDB/${sizeToLoad}`).once('value');
    if(snap && snap.exists()){ const val = snap.val(); window.localStorage.setItem('pdb_'+sizeToLoad, JSON.stringify(val)); console.log('Imported patternDB to localStorage'); return val; }
  }catch(e){ console.warn(e); }
  return null;
}

</script>
</body>
  </html>
