<!DOCTYPE html>
<html lang="bn" class="scroll-smooth">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sliding Puzzle ‚Äî Solver (Final)</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat libs -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    body { background:#0d1117; color:#c9d1d9; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    #homeScreen,#gameContainer { background:#161b22cc; box-shadow:0 8px 24px rgba(12,17,23,0.6); }
    #toggleSlider { background:#238636; }
    .tile {
      position:absolute;
      width: calc(100% / var(--grid-size) - 0.75rem);
      height: calc(100% / var(--grid-size) - 0.75rem);
      display:flex; align-items:center; justify-content:center;
      border-radius:0.5rem; cursor:pointer; user-select:none;
      font-size:2.5rem; font-weight:800; color:#e1e4e8;
      background:linear-gradient(145deg,#3a3f4b,#2c303a);
      box-shadow:0 6px 12px rgba(0,0,0,0.8), inset 0 3px 6px rgba(255,255,255,0.05);
      transition: transform 0.3s ease;
      text-shadow:0 0 4px #0008; backface-visibility:hidden;
    }
    .tile.hard { font-size:1.5rem; }
    .tile:hover { background:linear-gradient(145deg,#2c5f37,#1f3f22); color:#7fffd4; box-shadow:0 10px 20px rgba(35,134,54,0.7), inset 0 3px 7px rgba(255,255,255,0.15); transform:scale(1.1) var(--translate); z-index:10; text-shadow:0 0 8px #7fffd4cc; }
    .tile.empty { background:transparent; box-shadow:none; cursor:default; pointer-events:none; }
    #grid { position:relative; width:100%; height:100%; --grid-size:3; }
    /* modalOverlay default hidden; don't use Tailwind classes that force display */
    #modalOverlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.8); align-items:center; justify-content:center; z-index:100; }
    #modal { background:#21262d; padding:2rem; border-radius:1rem; text-align:center; box-shadow:0 4px 20px rgba(0,0,0,0.7); }
    #modal h2 { font-size:2rem; margin-bottom:1rem; color:#58a6ff; }
    #modal button { margin-top:1rem; padding:0.75rem 1.5rem; background:#238636; color:white; border:none; border-radius:0.5rem; font-size:1rem; cursor:pointer; transition:background 0.2s; }
    #modal button:hover { background:#2ea043; }
    #controls { width:100%; max-width:40rem; margin-top:36px; display:none; justify-content:center; gap:12px; align-items:center; }

    .controls-column { width:100%; display:flex; flex-direction:column; gap:10px; align-items:center; }
    .btn-wide { width:100%; max-width:360px; padding:0.72rem 1.2rem; border-radius:0.75rem; font-size:1.05rem; font-weight:700; cursor:pointer; color:white; border:none; box-shadow:0 8px 20px rgba(0,0,0,0.6); }
    #solveBtn { background:#16a34a; }
    #setCustomBtn { background:#0ea5a4; }
    #solveBtn:hover{ background:#169e43; transform:translateY(-2px); }
    #setCustomBtn:hover{ background:#119191; transform:translateY(-2px); }
    #solveBtn:disabled{ background:#285c38; cursor:not-allowed; opacity:.85; transform:translateY(0); }

    #customWrapper { width:100%; max-width:360px; display:none; margin-top:6px; }
    #customInputArea { display:flex; gap:8px; align-items:center; }
    #customInput { flex:1; padding:0.6rem 0.75rem; border-radius:0.6rem; background:#0b1116; color:#e6eef6; border:1px solid #253036; font-family:monospace; font-size:0.95rem; }
    #computeBtn { padding:0.5rem 0.9rem; background:#7c3aed; color:white; border-radius:0.6rem; cursor:pointer; border:none; font-weight:700; }
    #computeBtn:hover{ background:#6a2bd1; }
    #computeInfoBtn { margin-top:8px; background:transparent; color:#9fb3c8; border:none; cursor:pointer; text-decoration:underline; }

    #thinkingSmall { display:block; margin-top:6px; font-size:0.85em; color:#ddd; }
    #thinking-container {
      max-width: 360px;
      margin: 20px auto 40px auto;
      padding: 18px 22px;
      background-color: #202124;
      border-radius: 14px;
      box-shadow:0 0 0 1px rgba(255,255,255,0.1), 0 1px 3px rgba(0,0,0,0.4);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #e8eaed;
      user-select: none;
    }
    #thinking-text { font-size: 1.3rem; font-weight: 600; position: relative; overflow: hidden; display: inline-block; white-space: nowrap; background: linear-gradient(90deg,#e8eaed 20%,#121212 40%,#e8eaed 60%); background-repeat: no-repeat; background-size: 200% 100%; -webkit-background-clip: text; -webkit-text-fill-color: transparent; animation: shine-slide 2.5s linear infinite; }
    @keyframes shine-slide { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    #thinking-subtext { margin-top: 12px; font-style: italic; font-weight: 400; color: #c7c7c7; min-height: 26px; font-size: 1rem; white-space: nowrap; }

    #progressBarWrap { width:100%; max-width:34rem; margin:20px auto 0 auto; background:#23272e; border-radius:0.7rem; height:1.2rem; box-shadow:0 2px 8px #0005; overflow:hidden; position:relative; }
    #progressBar { height:100%; background:linear-gradient(90deg,#238636,#58a6ff); width:0%; transition:width 0.5s; }
    #progressText { position:absolute; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; font-size:.98rem; color:#fff; font-weight:700; text-shadow:0 2px 8px #0009; pointer-events:none; }

    #computeInfoOverlay { display:none; position:fixed; inset:0; z-index:140; display:flex; align-items:flex-end; justify-content:center; pointer-events:none; }
    #computeInfoPanel { width:100%; max-width:720px; margin:0 auto; pointer-events:auto; }
    #computeInfoInner { background:#0f1720; color:#cfe6ff; padding:18px; border-top-left-radius:12px; border-top-right-radius:12px; box-shadow:0 -8px 40px rgba(0,0,0,0.7); }

    #computeCardOverlay { display:none; position:fixed; inset:0; align-items:center; justify-content:center; z-index:150; }
    #computeCard { width:min(680px,95%); background:rgba(16,20,24,0.94); border-radius:12px; padding:18px; color:#e6eef6; box-shadow:0 10px 40px rgba(0,0,0,0.7); backdrop-filter: blur(6px); }
    #computeCard h3 { font-size:1.25rem; margin-bottom:6px; color:#58a6ff; }
    #computeCard .moves { display:flex; flex-wrap:wrap; gap:8px; margin-top:10px; }
    .pill { background:#17202a; padding:6px 8px; border-radius:8px; font-weight:700; }
    #computeCard .bottom { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }
    #saveStatus { margin-right:auto; align-self:center; color:#9fb3c8; }

    .dim-background { filter: blur(4px) brightness(0.6); pointer-events: none; }

    @media (max-width:640px){ #controls{ padding:0 12px; margin-top:26px; } .btn-wide{ max-width:92%; } }
  </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-6">

  <!-- Home -->
  <div id="homeScreen" class="w-full max-w-md p-8 rounded-3xl text-center mb-10 select-none">
    <h1 class="text-white text-5xl font-extrabold mb-8 drop-shadow-lg">Sliding Puzzle Game</h1>
    <div class="relative inline-block w-full bg-gray-800 rounded-full overflow-hidden shadow-inner">
      <div id="toggleSlider" class="absolute top-0 left-0 rounded-full h-full w-1/3 transition-all duration-300 ease-in-out"></div>
      <div class="flex text-gray-300 font-semibold text-xl cursor-pointer">
        <div data-mode="easy" class="flex-1 py-4 z-10">Easy</div>
        <div data-mode="normal" class="flex-1 py-4 z-10">Normal</div>
        <div data-mode="hard" class="flex-1 py-4 z-10">Hard</div>
      </div>
    </div>
    <button id="startBtn" class="mt-10 w-full bg-green-600 hover:bg-green-700 text-white py-4 rounded-2xl text-2xl font-semibold shadow-lg transition duration-300">
      Start Game
    </button>
    <p class="text-sm text-gray-400 mt-3">‡¶ó‡ßá‡¶Æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶π‡¶≤‡ßá ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ <strong>Solve</strong> ‡¶¨‡¶æ‡¶ü‡¶® ‡¶¶‡¶ø‡ßü‡ßá ‡¶¨‡¶ü ‡¶ö‡¶æ‡¶≤‡¶æ‡¶ì (‡¶¨‡¶æ ‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶°‡ßá <strong>B</strong> ‡¶ö‡¶æ‡¶™‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßã)‡•§</p>
  </div>

  <!-- Game container -->
  <div id="gameContainer" class="hidden w-full max-w-lg aspect-square rounded-3xl p-6 flex flex-col relative">
    <div id="grid"></div>
  </div>

  <!-- Progress bar -->
  <div id="progressBarWrap" style="display:none;">
    <div id="progressBar"></div>
    <div id="progressText"></div>
  </div>

  <!-- Controls -->
  <div id="controls">
    <div class="controls-column">
      <div id="thinkingSmall" aria-hidden="true"></div>
      <div id="winner-message"></div>
      <div id="game-board"></div>
      <div id="thinking-container" role="status" aria-live="polite" aria-atomic="true" aria-label="Bot thinking status">
        <div id="thinking-text">Solving With Stages...</div>
        <!-- ensure subtext element exists so typing loop won't busy-loop -->
        <div id="thinking-subtext"></div>
      </div>

      <button id="solveBtn" class="btn-wide" title="Bot Solve">Solve</button>
      <button id="setCustomBtn" class="btn-wide">Set Custom Position</button>

      <div id="customWrapper">
        <div id="customInputArea">
          <input id="customInput" placeholder="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: 1 2 3 ... 24 _ (25 ‡¶ü‡ßã‡¶ï‡ßá‡¶®, _ ‡¶π‡¶≤ empty)" />
          <button id="computeBtn">Compute</button>
        </div>
        <button id="computeInfoBtn" style="background:transparent;border:none;color:#9fb3c8;margin-top:8px;text-decoration:underline;">Compute ‡¶ì Efficiency ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡ßá ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</button>
      </div>
    </div>
  </div>

  <!-- Modal (hidden by default) -->
  <div id="modalOverlay">
    <div id="modal">
      <h2>üéâ You Solved It!</h2>
      <p class="text-gray-300">Congratulations on completing the puzzle.</p>
      <button id="closeModal">Close</button>
    </div>
  </div>

  <!-- Compute info slide-up modal -->
  <div id="computeInfoOverlay">
    <div id="computeInfoPanel">
      <div id="computeInfoInner">
        <h3 style="color:#58a6ff; font-size:1.2rem; margin-bottom:6px;">Compute & Efficiency</h3>
        <p style="color:#b9d0e6; line-height:1.45;">Compute ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ø‡ßá custom state ‡¶¶‡ßá‡¶¨‡ßá‡¶®, ‡¶∏‡ßá‡¶ü‡¶æ‡¶ï‡ßá ‡¶Ü‡¶Æ‡¶∞‡¶æ targeted BFS/limited-search ‡¶¶‡¶ø‡ßü‡ßá ‡¶®‡¶ø‡¶∞‡ßç‡¶¶‡¶ø‡¶∑‡ßç‡¶ü tile ‡¶ï‡ßá ‡¶§‡¶æ‡¶∞ goal position-‡¶è ‡¶¨‡¶∏‡¶æ‡¶§‡ßá ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡¶¨ ‚Äî ‡¶™‡ßÅ‡¶∞‡ßã 5√ó5-‡¶ï‡ßá IDA/complete solve ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡ßá ‡¶Ü‡¶Æ‡¶æ‡¶¶‡ßá‡¶∞ ‡¶≤‡¶ï‡ßç‡¶∑‡ßç‡¶Ø ‡¶è‡¶ï‡¶ï ‡¶ü‡¶æ‡¶á‡¶≤‡ßá‡¶∞ ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶†‡¶ø‡¶ï ‡¶ï‡¶∞‡¶æ‡•§</p>
        <ul style="color:#9fb3c8; margin-top:8px;">
          <li>‚Ä¢ compute-‡¶è node/time limits ‡¶Ü‡¶õ‡ßá ‚Äî ‡¶¨‡ßú search-‡¶è ‡¶¨‡ßç‡¶∞‡¶æ‡¶â‡¶ú‡¶æ‡¶∞ freeze ‡¶®‡¶æ ‡¶ï‡¶∞‡¶æ‡¶á ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶â‡¶¶‡ßç‡¶¶‡ßá‡¶∂‡ßç‡¶Ø‡•§</li>
          <li>‚Ä¢ Firebase-‡¶è cached result ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡ßá‡¶ü‡¶æ‡¶ï‡ßá ‡¶Ü‡¶ó‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡ßã ‡¶π‡¶¨‡ßá ‚Äî ‡¶®‡¶§‡ßÅ‡¶® compute ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞ ‡¶π‡¶¨‡ßá ‡¶®‡¶æ‡•§</li>
          <li>‚Ä¢ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ü‡¶æ‡¶á‡¶≤‡¶ó‡ßÅ‡¶≤‡ßã ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ‡¶≠‡¶æ‡¶¨‡ßá 1 ‡¶•‡ßá‡¶ï‡ßá 24 ‡¶™‡¶∞‡ßç‡¶Ø‡¶®‡ßç‡¶§ serially compute ‡¶ì save ‡¶ï‡¶∞‡¶≤‡ßá ‡¶™‡¶∞‡ßá ‡¶ì‡¶á ‡¶ü‡¶æ‡¶á‡¶≤ ‡¶Ø‡ßá‡¶á ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡¶§‡ßá‡¶á ‡¶•‡¶æ‡¶ï‡ßÅ‡¶ï ‡¶®‡¶æ ‡¶ï‡ßá‡¶® cached moves ‡¶ï‡¶æ‡¶ú‡ßá ‡¶≤‡¶æ‡¶ó‡¶¨‡ßá‡•§</li>
          <li>‚Ä¢ ‡¶Ü‡¶™‡¶®‡¶ø 1..8,9..16,17..24 ‡¶ü‡ßÅ‡¶ï‡¶∞‡¶æ ‡¶§‡¶ø‡¶®‡¶ü‡¶ø ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ Firebase ‡¶™‡ßç‡¶∞‡¶ú‡ßá‡¶ï‡ßç‡¶ü‡ßá ‡¶∞‡¶æ‡¶ñ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡¶® ‚Äî configs code-‡¶è ‡¶¨‡¶∏‡¶æ‡¶®‡ßã ‡¶Ü‡¶õ‡ßá‡•§</li>
        </ul>
        <div style="display:flex; justify-content:space-between; margin-top:12px;">
          <button id="closeInfoBtn" style="background:#16a34a; color:white; padding:8px 12px; border-radius:8px; border:none;">Close</button>
          <button id="learnMoreBtn" style="background:transparent; color:#9fb3c8; border:none; text-decoration:underline;">More details (dev)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Compute result card overlay -->
  <div id="computeCardOverlay">
    <div id="computeCard">
      <div style="display:flex; gap:12px; align-items:start;">
        <div style="flex:1;">
          <h3 id="cardTitle">Compute Result</h3>
          <div id="cardMeta" style="color:#9fb3c8; font-size:0.95rem;">Tile: <strong id="metaTile">-</strong> ‚Ä¢ Pos: <strong id="metaPos">-</strong></div>
          <div style="margin-top:8px;">Moves:</div>
          <div id="movesList" class="moves"></div>
          <div class="bottom">
            <div id="saveStatus">Not saved yet</div>
            <button id="cardClose" style="background:#444; color:white; padding:8px 12px; border-radius:8px; border:none;">Close</button>
            <button id="cardSave" style="background:#0ea5a4; color:white; padding:8px 12px; border-radius:8px; border:none;">Save to Firebase</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* ------------------ three firebase configs (user-provided) ------------------ */
const config1 = {
  apiKey: "AIzaSyCMEqtaxOodPnwMKkrSVZrcjLMmj3oefB0",
  authDomain: "chatstudio-agent.firebaseapp.com",
  databaseURL: "https://chatstudio-agent-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "chatstudio-agent",
  storageBucket: "chatstudio-agent.firebasestorage.app",
  messagingSenderId: "626338448826",
  appId: "1:626338448826:web:67936971701c3466d90983",
  measurementId: "G-ZHNZHMYC0B"
};
const config2 = {
  apiKey: "AIzaSyAKd2WmThKb4OM9pv0Bx9vtunmGpRGxczM",
  authDomain: "puzzle-solver-5-2.firebaseapp.com",
  databaseURL: "https://puzzle-solver-5-2-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "puzzle-solver-5-2",
  storageBucket: "puzzle-solver-5-2.firebasestorage.app",
  messagingSenderId: "221283910343",
  appId: "1:221283910343:web:0bef0b54fe26e594c8f4e2"
};
const config3 = {
  apiKey: "AIzaSyDohgyc4pRldMVxbFRTkHnNfAIczf8JHMo",
  authDomain: "puzzle-solver-4-1.firebaseapp.com",
  databaseURL: "https://puzzle-solver-4-1-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "puzzle-solver-4-1",
  storageBucket: "puzzle-solver-4-1.firebasestorage.app",
  messagingSenderId: "422133823015",
  appId: "1:422133823015:web:0daf2ce34fa8fe98eac002"
};
/* --------------------------------------------------------------------------- */

/* ---------- The main app logic (solver + UI + firebase) ---------- */
// (This is the same solver logic you provided, kept intact where requested; fixes applied for UI bugs)

const modes = { easy:{size:3, path:'easy'}, normal:{size:4, path:'normal'}, hard:{size:5, path:'hard'} };
let currentMode = 'easy';
const homeScreen = document.getElementById('homeScreen');
const gameContainer = document.getElementById('gameContainer');
const gridEl = document.getElementById('grid');
const toggleSlider = document.getElementById('toggleSlider');
const startBtn = document.getElementById('startBtn');
const modalOverlay = document.getElementById('modalOverlay');
const closeModal = document.getElementById('closeModal');
const controls = document.getElementById('controls');
const solveBtn = document.getElementById('solveBtn');
const setCustomBtn = document.getElementById('setCustomBtn');
const customWrapper = document.getElementById('customWrapper');
const customInput = document.getElementById('customInput');
const computeBtn = document.getElementById('computeBtn');
const computeInfoBtn = document.getElementById('computeInfoBtn');
const computeInfoOverlay = document.getElementById('computeInfoOverlay');
const closeInfoBtn = document.getElementById('closeInfoBtn');
const computeCardOverlay = document.getElementById('computeCardOverlay');
const metaTile = document.getElementById('metaTile');
const metaPos = document.getElementById('metaPos');
const movesList = document.getElementById('movesList');
const cardClose = document.getElementById('cardClose');
const cardSave = document.getElementById('cardSave');
const saveStatus = document.getElementById('saveStatus');
const progressBarWrap = document.getElementById('progressBarWrap');
const progressBar = document.getElementById('progressBar');
const progressText = document.getElementById('progressText');

let size, tiles = [], emptyIndex;

// Mode switch with URL update
document.querySelectorAll('[data-mode]').forEach(el=>{
  el.addEventListener('click', ()=> {
    currentMode = el.dataset.mode;
    const idx = ['easy','normal','hard'].indexOf(currentMode);
    toggleSlider.style.left = `${idx*33.3333}%`;
    const p = modes[currentMode].path;
    if(location.pathname!=="/"+p) history.replaceState({}, '', "/"+p);
  });
});
(function setModeFromUrl(){
  const path = location.pathname.replace(/^\//,'');
  if(path && Object.values(modes).some(m=>m.path===path)){
    currentMode = Object.keys(modes).find(k=>modes[k].path===path) || "easy";
  }
  const idx = ['easy','normal','hard'].indexOf(currentMode);
  toggleSlider.style.left = `${idx*33.3333}%`;
})();

function getTranslate(index){
  const row = Math.floor(index/size), col = index%size;
  const tileSize = gridEl.clientWidth/size;
  return { x: col*tileSize, y: row*tileSize };
}

function createGrid(gridSize){
  size = gridSize;
  gridEl.style.setProperty('--grid-size', size);
  gridEl.innerHTML = '';
  tiles = Array.from({length:size*size-1},(_,i)=>i+1);
  tiles.push(null);
  shuffleTiles(tiles,size);
  emptyIndex = tiles.indexOf(null);

  tiles.forEach((num,i)=>{
    if(num===null) return;
    const tile = document.createElement('div');
    tile.className = 'tile';
    if(currentMode==='hard') tile.classList.add('hard');
    tile.textContent = num;
    const {x,y} = getTranslate(i);
    tile.style.transform = `translate(${x}px,${y}px)`;
    tile.dataset.number = num;
    tile.dataset.position = i;
    gridEl.appendChild(tile);
  });
  controls.style.display = 'flex';
  progressBarWrap.style.display = 'block';
  updateProgressBar();
}

function shuffleTiles(arr,s){
  do{
    for(let i=arr.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [arr[i],arr[j]]=[arr[j],arr[i]];
    }
  }while(!isSolvable(arr,s)||isSolved(arr));
}

function isSolvable(arr,s){
  let inv=0, flat=arr.filter(x=>x!==null);
  for(let i=0;i<flat.length;i++)
    for(let j=i+1;j<flat.length;j++)
      if(flat[i]>flat[j]) inv++;
  if(s%2) return inv%2===0;
  const er = Math.floor(arr.indexOf(null)/s);
  return er%2?inv%2===0:inv%2!==0;
}

function isSolved(arr){
  for(let i=0;i<arr.length-1;i++) if(arr[i]!==i+1) return false;
  return arr[arr.length-1]===null;
}

function tryMove(tile){
  const tilePos = +tile.dataset.position;
  const emptyPos = emptyIndex;
  const r1 = Math.floor(tilePos/size), c1 = tilePos%size;
  const r2 = Math.floor(emptyPos/size), c2 = emptyPos%size;
  const adj = (r1===r2 && Math.abs(c1-c2)===1) || (c1===c2 && Math.abs(r1-r2)===1);
  if(!adj) return false;
  [tiles[tilePos],tiles[emptyPos]]=[tiles[emptyPos],tiles[tilePos]];
  const {x,y} = getTranslate(emptyPos);
  tile.style.transform = `translate(${x}px,${y}px)`;
  tile.dataset.position = emptyPos;
  emptyIndex = tilePos;
  updateProgressBar();
  return true;
}

gridEl.addEventListener('click', e=>{
  const tile = e.target.closest('.tile');
  if(!tile) return;
  if(tryMove(tile) && isSolved(tiles)){
    modalOverlay.style.display = 'flex';
    updateProgressBar();
  }
});

startBtn.addEventListener('click', ()=>{
  homeScreen.classList.add('hidden');
  gameContainer.classList.remove('hidden');
  createGrid(modes[currentMode].size);
});

closeModal.addEventListener('click', ()=>{ modalOverlay.style.display = 'none'; });

window.addEventListener('resize', ()=>{
  tiles.forEach(num=>{
    if(num===null) return;
    const tile = [...gridEl.children].find(t=>+t.dataset.number===num);
    if(!tile) return;
    const {x,y} = getTranslate(+tile.dataset.position);
    tile.style.transform = `translate(${x}px,${y}px)`;
  });
});

// Progress bar calculation
function calcProgress(arr, sz){
  if(sz===3) {
    let cnt=0;
    for(let i=0;i<8;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/8*100);
  }
  if(sz===4) {
    let cnt=0;
    for(let i=0;i<15;i++) if(arr[i]===i+1) cnt++;
    return Math.round(cnt/15*100);
  }
  if(sz===5){
    let stage1=0, total=0;
    const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
    for(const i of st1idx) if(arr[i]===i+1) stage1++;
    for(let i=0;i<24;i++) if(arr[i]===i+1) total++;
    return Math.round((stage1/12*70)+(total/24*30));
  }
  return 0;
}

function updateProgressBar(){
  if(!tiles||!size) return;
  const perc = calcProgress(tiles,size);
  progressBar.style.width = perc+"%";
  progressText.textContent = perc+"% solved";
  if(perc===100) progressText.textContent = "üéâ Puzzle Solved!";
}

// Worker solver function (kept original algorithms)
function solverWorkerFunction(){
  self.onmessage = function(ev){
    try{
      const {type, state, size, targetTile} = ev.data;
      if(type !== 'solve' && type !== 'compute_tile') return;
      const startState = state.slice();

      function idxToRC(i){ return {r: Math.floor(i/size), c: i%size}; }
      const goalPos = {}; for(let v=1; v<=size*size-1; v++) goalPos[v] = idxToRC(v-1);

      function manhattanUnfixed(arr, fixedSet){
        let s = 0;
        for(let i=0;i<arr.length;i++){
          const v = arr[i]; if(v==null) continue;
          const gi = v-1; if(fixedSet && fixedSet.has(gi)) continue;
          const cur = idxToRC(i), g = goalPos[v];
          if(!g) continue;
          s += Math.abs(cur.r - g.r) + Math.abs(cur.c - g.c);
        }
        return s;
      }

      function neighborsOfEmpty(emptyIdx){
        const res=[];
        const r=Math.floor(emptyIdx/size), c=emptyIdx%size;
        const deltas=[{dr:-1,dc:0},{dr:1,dc:0},{dr:0,dc:-1},{dr:0,dc:1}];
        for(const d of deltas){
          const nr=r+d.dr, nc=c+d.dc;
          if(nr>=0 && nr<size && nc>=0 && nc<size) res.push(nr*size+nc);
        }
        return res;
      }

      function bfsPlaceTile(currentState, fixedSet, targetVal, targetGoalIdx){
        const start = currentState.slice();
        const startEmpty = start.indexOf(null);
        const key = s => s.map(x=>x===null?'_':x).join(',');
        const Queue = [];
        const Seen = new Set();
        Queue.push({arr:start.slice(), empty:startEmpty, path:[]});
        Seen.add(key(start));
        const maxNodes = 400000;
        let nodes=0;
        const maxDepth = 80;
        while(Queue.length){
          const node = Queue.shift();
          nodes++;
          if(nodes > maxNodes) break;
          if(node.arr[targetGoalIdx] === targetVal) return node.path.slice();
          if(node.path.length >= maxDepth) continue;
          const neigh = neighborsOfEmpty(node.empty);
          for(const idx of neigh){
            if(fixedSet && fixedSet.has(idx)) continue;
            const newA = node.arr.slice();
            const moved = newA[idx];
            newA[node.empty] = moved;
            newA[idx] = null;
            const k = key(newA);
            if(Seen.has(k)) continue;
            Seen.add(k);
            const newPath = node.path.slice(); newPath.push(moved);
            Queue.push({arr:newA, empty: idx, path:newPath});
          }
        }
        return null;
      }

      function idaPlaceTarget(currentState, fixedSet, targetVal, targetGoalIdx, nodeCap=600_000, tCap=10_000){
        const state = currentState.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, fixedSet); }
        let threshold = h();
        const path = [];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, fixedSet);
          const f = g + hv;
          if(f > threshold) return f;
          if(state[targetGoalIdx] === targetVal) { found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            if(fixedSet.has(idx)) return {idx, hv2: 1e9};
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, fixedSet);
            state[idx]=val; state[eidx]=null;
            return {idx, hv2};
          }).filter(Boolean).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti = o.idx;
            if(prev !== undefined && ti === prev) continue;
            if(fixedSet.has(ti)) continue;
            const v = state[ti];
            state[eidx] = v; state[ti] = null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r === 'FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti] = v; state[eidx] = null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r === 'FOUND') return found;
          if(r === Infinity || nodes > nodeCap) break;
          threshold = r;
          if(Date.now() - t0 > tCap) break;
        }
        return null;
      }

      function idaFull(initial, nodeCap=5_000_000, tCap=30_000){
        const state = initial.slice();
        let empty = state.indexOf(null);
        let nodes=0;
        function h(){ return manhattanUnfixed(state, new Set()); }
        let threshold = h();
        const path=[];
        let found=null;
        function dfs(eidx, g, prev){
          nodes++;
          if(nodes>nodeCap) return Infinity;
          const hv = manhattanUnfixed(state, new Set());
          const f = g + hv;
          if(f > threshold) return f;
          if(hv===0){ found = path.slice(); return 'FOUND'; }
          let min=Infinity;
          const neigh = neighborsOfEmpty(eidx);
          const order = neigh.map(idx=>{
            const val = state[idx];
            state[eidx]=val; state[idx]=null;
            const hv2 = manhattanUnfixed(state, new Set());
            state[idx]=val; state[eidx]=null;
            return {idx,hv2};
          }).sort((a,b)=>a.hv2-b.hv2);
          for(const o of order){
            const ti=o.idx;
            if(prev !== undefined && ti===prev) continue;
            const v = state[ti];
            state[eidx]=v; state[ti]=null;
            path.push(v);
            const r = dfs(ti, g+1, eidx);
            if(r==='FOUND') return 'FOUND';
            if(r < min) min = r;
            path.pop();
            state[ti]=v; state[eidx]=null;
          }
          return min;
        }
        const t0 = Date.now();
        while(true){
          nodes=0;
          const r = dfs(empty, 0, undefined);
          if(r==='FOUND') return found;
          if(r===Infinity || nodes>nodeCap) break;
          threshold = r;
          if(Date.now()-t0 > tCap) break;
        }
        return null;
      }

      if(type === 'compute_tile'){
        const working = startState.slice();
        const targetVal = targetTile;
        const goalIdx = targetVal - 1;
        const fixed = new Set();
        const moves = bfsPlaceTile(working, fixed, targetVal, goalIdx);
        self.postMessage({type:'compute_result', target:targetVal, moves:moves});
        return;
      }

      // full solver preserved
      if(size === 4){
        const working = startState.slice();
        let allMoves = [];
        const fixedIndices = new Set();
        try{
          for(let c=0; c<size; c++){
            const targetVal = c+1;
            const goalIdx = c;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 300000, 4000);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          for(let i=4;i<=5;i++){
            const targetVal = i+1;
            const goalIdx = i;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue; }
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 200000, 3500);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'4x4_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'4x4_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          const restMoves = idaFull(working, 600000, 16000);
          if(restMoves&&restMoves.length>0){
            for(const mv of restMoves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            self.postMessage({type:'done', moves:allMoves, method:'4x4_stage2_ida'});
            return;
          }else{
            self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'4x4_stage2_fail'});
            return;
          }
        }catch(e){
          self.postMessage({type:'done', moves:null, method:'4x4_exception', error:String(e)});
          return;
        }
      }

      if(size===5){
        const st1idx=[0,1,2,3,4,5,6,7,8,9,10,11];
        const working = startState.slice();
        let allMoves = [];
        const fixedIndices = new Set();
        try{
          for(const i of st1idx){
            const targetVal = i+1;
            const goalIdx = i;
            if(working[goalIdx]===targetVal){ fixedIndices.add(goalIdx); continue;}
            let moves = idaPlaceTarget(working, fixedIndices, targetVal, goalIdx, 170000, 3000);
            if(!moves) moves = bfsPlaceTile(working, fixedIndices, targetVal, goalIdx);
            if(!moves){ self.postMessage({type:'done', moves:null, method:'5x5_stage1_fail', tile:targetVal}); return; }
            for(const mv of moves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            if(working[goalIdx]!==targetVal){ self.postMessage({type:'done', moves:null, method:'5x5_not_placed', tile:targetVal}); return;}
            fixedIndices.add(goalIdx);
          }
          const restMoves = idaFull(working, 400000, 9000);
          if(restMoves&&restMoves.length>0){
            for(const mv of restMoves){
              const fromIdx = working.indexOf(mv);
              const eIdx = working.indexOf(null);
              working[eIdx]=mv; working[fromIdx]=null;
              allMoves.push(mv);
            }
            self.postMessage({type:'done', moves:allMoves, method:'5x5_stage2_ida'});
            return;
          }else{
            self.postMessage({type:'done', moves:allMoves.length?allMoves:null, method:'5x5_stage2_fail'});
            return;
          }
        }catch(e){
          self.postMessage({type:'done', moves:null, method:'5x5_exception', error:String(e)});
          return;
        }
      }

      if(size<=3){
        const moves = idaFull(startState);
        self.postMessage({type:'done', moves:moves, method:'3x3_ida'});
        return;
      }

      const fallback = idaFull(startState, 150000, 7000);
      self.postMessage({type:'done', moves:fallback, method:'fallback_ida'});
    }catch(e){
      self.postMessage({type:'done', moves:null, method:'worker_crash', error: String(e)});
    }
  };
}

// create worker
const workerBlob = new Blob(['('+solverWorkerFunction.toString()+')()'], {type:'application/javascript'});
const workerUrl = URL.createObjectURL(workerBlob);
let solverWorker = null;
let solverRunning = false;
let queuedMoves = [];

function startSolver(){
  if(solverRunning) return;
  if(gameContainer.classList.contains('hidden')) return;
  solverRunning = true;
  solveBtn.disabled = true;
  gridEl.style.pointerEvents = 'none';
  const snapshot = tiles.slice();
  solverWorker = new Worker(workerUrl);
  solverWorker.onmessage = function(ev){
    const data = ev.data;
    const moves = data.moves;
    if(!moves){
      solveBtn.disabled = false;
      gridEl.style.pointerEvents = '';
      solverRunning = false;
      let msg = 'Solver failed or timed out.';
      if(data && data.method){
        if(data.method.startsWith('4x4_stage1_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡ßß-‡ß¨ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('4x4_stage2_fail')) msg="‡ß™√ó‡ß™ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage1_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡ßß‡¶Æ ‡ßß‡ß®‡¶ü‡¶æ tile stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else if(data.method.startsWith('5x5_stage2_fail')) msg="‡ß´√ó‡ß´ puzzle: ‡¶∂‡ßá‡¶∑ stage-‡¶è ‡¶Ü‡¶ü‡¶ï‡ßá ‡¶ó‡ßá‡¶õ‡ßá!";
        else msg = 'Solver could not finish (method: '+data.method+').';
      }
      alert(msg);
      if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
      return;
    }
    applyMovesSequence(moves);
  };
  solverWorker.postMessage({type:'solve', state: snapshot, size});
}

function stopSolverNow(){
  if(solverWorker){ solverWorker.terminate(); solverWorker = null; }
  solverRunning = false;
  solveBtn.disabled = false;
  gridEl.style.pointerEvents = '';
  queuedMoves = [];
}

function applyMovesSequence(moves){
  let i = 0;
  queuedMoves = moves;
  const delay = 340;
  function step(){
    if(i >= moves.length){
      stopSolverNow();
      if(isSolved(tiles)) modalOverlay.style.display = 'flex';
      updateProgressBar();
      return;
    }
    const val = moves[i];
    const tile = [...gridEl.children].find(t => +t.dataset.number === val);
    if(tile) tryMove(tile);
    i++;
    updateProgressBar();
    setTimeout(step, delay);
  }
  setTimeout(step, 200);
}

solveBtn.addEventListener('click', startSolver);
window.addEventListener('keydown', (e)=>{
  if((e.key === 'b' || e.key === 'B') && !gameContainer.classList.contains('hidden')) startSolver();
  if(e.key === 'Escape' && solverRunning) stopSolverNow();
});

window.addEventListener('beforeunload', ()=>{ if(solverWorker) solverWorker.terminate(); });

// Typing effect - fixed to avoid busy-loop if element missing
(function(){
  const subTextEl = document.getElementById('thinking-subtext');
  const messages = [
    'Analyzing with Python simulation...',
    'Evaluating heuristics...',
    'Running Minimax algorithm...',
    'Performing Monte-Carlo simulations...',
    'Checking board states...',
    'Detecting chains and loops...',
    'Applying corner and edge heuristics...',
    'Assessing sacrifice moves...',
    'Generating probabilistic outcomes...',
    'Optimizing move selection...',
    'Calculating risk factors...',
    'Scanning for traps...',
    'Validating opponent\'s options...',
    'Updating strategy matrix...',
    'Preparing final move...',
    'Almost done...',
    'Move ready to execute!',
    '‡¶¨‡¶ü ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶õ‡ßá... ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®!',
    'Solver ‡¶¨‡ßÅ‡¶¶‡ßç‡¶ß‡¶ø ‡¶ñ‡¶æ‡¶ü‡¶æ‡¶ö‡ßç‡¶õ‡ßá...',
    '‡¶™‡¶æ‡¶ú‡ßá‡¶≤ ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...'
  ];
  let idx = 0;
  function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }
  async function typeEffect(text, element, delay=40) {
    if(!element){
      // element missing ‚Äî wait a bit to avoid busy-loop
      await wait(900);
      return;
    }
    element.textContent = '';
    for(let i=0;i<text.length;i++){
      element.textContent += text.charAt(i);
      await wait(delay);
    }
    await wait(900);
  }
  async function loopMessages() {
    while(true) {
      await typeEffect(messages[idx], subTextEl);
      idx = (idx + 1) % messages.length;
    }
  }
  loopMessages();
})();

// ---------------- CUSTOM COMPUTE & FIREBASE ----------------
function stateKey(arr){ return arr.map(v=>v===null?'_':v).join(','); }

const firebaseApps = { a: null, b: null, c: null };
function initFirebaseApps(){
  try{
    if(typeof firebase === 'undefined') return;
    if(config1 && !firebaseApps.a){ firebaseApps.a = firebase.initializeApp(config1, 'app1'); }
    if(config2 && !firebaseApps.b){ firebaseApps.b = firebase.initializeApp(config2, 'app2'); }
    if(config3 && !firebaseApps.c){ firebaseApps.c = firebase.initializeApp(config3, 'app3'); }
  }catch(e){ console.warn('Firebase init error', e); }
}
function getDbForTile(tile){
  if(tile>=1 && tile<=8) return firebaseApps.a ? firebaseApps.a.database() : null;
  if(tile>=9 && tile<=16) return firebaseApps.b ? firebaseApps.b.database() : null;
  if(tile>=17 && tile<=24) return firebaseApps.c ? firebaseApps.c.database() : null;
  return null;
}

setCustomBtn.addEventListener('click', ()=>{
  customWrapper.style.display = (customWrapper.style.display === 'flex' || customWrapper.style.display === 'block')? 'none' : 'block';
});
computeInfoBtn.addEventListener('click', ()=>{ computeInfoOverlay.style.display = 'flex'; });
closeInfoBtn && closeInfoBtn.addEventListener('click', ()=>{ computeInfoOverlay.style.display = 'none'; });
computeInfoOverlay.addEventListener('click', (e)=>{ if(e.target === computeInfoOverlay) computeInfoOverlay.style.display='none'; });

function showComputeCard(tile, posIdx, movesArray){
  metaTile.textContent = tile;
  metaPos.textContent = posIdx;
  movesList.innerHTML = '';
  if(movesArray && movesArray.length){
    for(const m of movesArray){
      const el = document.createElement('div'); el.className='pill'; el.textContent = m; movesList.appendChild(el);
    }
  } else {
    const el = document.createElement('div'); el.style.color='#9fb3c8'; el.textContent = 'No moves found / timed out'; movesList.appendChild(el);
  }
  saveStatus.textContent = 'Not saved yet';
  computeCardOverlay.style.display = 'flex';
  document.body.classList.add('dim-background');
}
function hideComputeCard(){ computeCardOverlay.style.display = 'none'; document.body.classList.remove('dim-background'); }
cardClose.addEventListener('click', hideComputeCard);

function parseCustomInput(text){
  const parts = text.split(/[ ,;]+/).map(x=>x.trim()).filter(Boolean);
  if(parts.length !== size*size) return null;
  const arr = parts.map(p=> p === '_' || p.toLowerCase()==='_' ? null : Number(p));
  if(arr.some((v,i)=> v !== null && (typeof v !== 'number' || v<1 || v>size*size-1))) return null;
  const vals = arr.filter(x=>x!==null);
  const set = new Set(vals);
  if(set.size !== vals.length) return null;
  return arr;
}

computeBtn.addEventListener('click', async ()=>{
  const txt = customInput.value.trim();
  const parsed = parseCustomInput(txt);
  if(!parsed){ alert('Invalid input. ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶â‡¶™‡¶∞‡ßá‡¶∞ ‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã 25 ‡¶ü‡ßã‡¶ï‡ßá‡¶® ‡¶¶‡¶ø‡¶® ‡¶è‡¶¨‡¶Ç _ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßá empty ‡¶¶‡¶ø‡¶®‡•§'); return; }
  tiles = parsed.slice();
  emptyIndex = tiles.indexOf(null);
  gridEl.innerHTML = '';
  tiles.forEach((num,i)=>{
    if(num===null) return;
    const tile = document.createElement('div'); tile.className='tile'; if(currentMode==='hard') tile.classList.add('hard'); tile.textContent=num; const {x,y}=getTranslate(i); tile.style.transform=`translate(${x}px,${y}px)`; tile.dataset.number=num; tile.dataset.position=i; gridEl.appendChild(tile);
  });
  updateProgressBar();

  let targetTile = null;
  for(let v=1; v<=size*size-1; v++){
    const currentIdx = tiles.indexOf(v);
    const goalIdx = v-1;
    if(currentIdx !== -1 && currentIdx !== goalIdx){ targetTile = v; break; }
  }
  if(!targetTile){ alert('‡¶™‡¶æ‡¶ú‡ßá‡¶≤‡¶ü‡¶ø ‡¶á‡¶§‡ßã‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡¶¨ ‡¶ü‡¶æ‡¶á‡¶≤ ‡¶∏‡¶†‡¶ø‡¶ï ‡¶Ö‡¶¨‡¶∏‡ßç‡¶•‡¶æ‡ßü ‡¶Ü‡¶õ‡ßá ‡¶¨‡¶æ ‡¶ü‡¶æ‡¶∞‡ßç‡¶ó‡ßá‡¶ü ‡¶ü‡¶æ‡¶á‡¶≤ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§'); return; }

  showComputeCard(targetTile, tiles.indexOf(targetTile), []);
  initFirebaseApps();

  const w = new Worker(workerUrl);
  w.onmessage = function(ev){
    const d = ev.data;
    if(d.type === 'compute_result'){
      const moves = d.moves;
      showComputeCard(d.target, tiles.indexOf(d.target), moves);
      const db = getDbForTile(d.target);
      if(!db){
        saveStatus.textContent = 'Firebase not configured for this tile range (provide config).';
        w.terminate();
        return;
      }
      const key = stateKey(tiles);
      const path = `tiles/${d.target}/${encodeURIComponent(key)}`;
      const ref = db.ref(path);
      ref.get().then(snap=>{
        if(snap.exists()){
          saveStatus.textContent = 'Already saved (cached).';
        } else {
          ref.set({ moves: moves || [], length: moves?moves.length:0, timestamp: Date.now() }).then(()=>{
            saveStatus.textContent = 'Saved ‚úÖ';
          }).catch(e=>{
            saveStatus.textContent = 'Save failed: '+e.message;
          });
        }
      }).catch(err=>{
        saveStatus.textContent = 'DB check failed: '+err.message;
      });
      w.terminate();
    }
  };
  w.postMessage({type:'compute_tile', state: tiles.slice(), size, targetTile});
});

cardSave.addEventListener('click', ()=>{
  const t = Number(metaTile.textContent);
  if(!t || isNaN(t)){ alert('No target tile in card'); return; }
  const db = getDbForTile(t);
  if(!db){ alert('Firebase not configured for this tile range.'); return; }
  const snapshot = tiles.slice();
  const key = stateKey(snapshot);
  const path = `tiles/${t}/${encodeURIComponent(key)}`;
  db.ref(path).get().then(snap=>{
    if(snap.exists()){ saveStatus.textContent = 'Already saved (cached).'; }
    else{
      const moves = Array.from(movesList.children).map(c=>c.textContent).filter(Boolean);
      db.ref(path).set({ moves: moves, length: moves.length, timestamp: Date.now() }).then(()=>{ saveStatus.textContent = 'Saved ‚úÖ'; }).catch(e=>{ saveStatus.textContent = 'Save failed: '+e.message; });
    }
  }).catch(err=>{ saveStatus.textContent = 'DB check failed: '+err.message; });
});

computeCardOverlay.addEventListener('click', (e)=>{ if(e.target === computeCardOverlay) hideComputeCard(); });

</script>
</body>
</html>
